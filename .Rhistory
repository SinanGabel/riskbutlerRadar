}
return(r)
}
sims <- funsim(xdata, model = "yckls", correlated = FALSE)
colnames(sims) <- c("CHF","SEK")
write.csv(as.table(sims), "./unisims-chan92.csv", row.names=FALSE)
sims <- funsim(xdata, model = "yckls", correlated = TRUE)
colnames(sims) <- c("CHF","SEK")
write.csv(as.table(sims), "./multisims-chan92.csv", row.names=FALSE)
sims <- funsim(xdata, model = "yhdf", correlated = FALSE)
colnames(sims) <- c("CHF","SEK")
write.csv(as.table(sims), "./unisims-hyperbolic.csv", row.names=FALSE)
sims <- funsim(xdata, model = "yckls", correlated = TRUE)
library(jsonlite)
library(yuima)
library(riskbutlerRadar)
library(foreach)
# - korreleret tidsserier
datalength <- 300
chf <- getData(request = list(class = "FX", base_currency = "DKK", currency = "CHF", frequency = "day", limit = datalength))
sek <- getData(request = list(class = "FX", base_currency = "DKK", currency = "SEK", frequency = "day", limit = datalength))
xdata <- data.frame(chf, sek)
write.csv(xdata, "./marketdata_daily_base_DKK.csv", row.names=FALSE)
cor(xdata)
plot(xdata)
# --
sekvens <- function(n, w, s) {
l <- seq(1, n - w + s, s)
if ((l[length(l)] + w - 1) > n ) {
l[length(l)] = n - w + 1
}
return(l)
}
l <- sekvens(datalength, 100, 10)
funparam <- function(data, model = "you3", correlated = FALSE) {
rho <- 0
if (correlated == TRUE) {
rho <- cor(data)[2,1]
}
# dX = θ1·(θ2 - X)·dt + θ3·X·dW, Brennan & Schwartz 1980
if (model == "you3") {
b <- c("p1.1 * (p2.1 - x1)", "p1.2 * (p2.2 - x2)")
e21 <- gsub("rho", rho, "(p3.2 * x2) * rho")
e22 <- gsub("rho", rho, "(p3.2 * x2) * sqrt(1 - (rho)^2)")
s <- matrix(c("p3.1 * x1", e21, 0, e22), 2, 2)
slu <- jsonlite::fromJSON('{"start": {"p1.1": 1,"p2.1": 0.1,"p3.1": 0.1, "p1.2": 1,"p2.2": 0.1,"p3.2": 0.1}, "lower": {"p1.1": -100,"p2.1": 0,"p3.1": 0, "p1.2": -100,"p2.2": 0,"p3.2": 0}, "upper": {"p1.1": 100,"p2.1": 100,"p3.1": 100, "p1.2": 100,"p2.2": 100,"p3.2": 100}}')
sol <- c("x1", "x2")
# dX = θ1·(θ2 - X)·dt + θ3·X^θ4·dW, Chan-Karolyi-Longstaff-Sanders 1992
} else if (model == "yckls") {
b <- c("p1.1 * (p2.1 - x1)", "p1.2 * (p2.2 - x2)")
e21 <- gsub("rho", rho, "(p3.2 * x2^p4.2) * rho")
e22 <- gsub("rho", rho, "(p3.2 * x2^p4.2) * sqrt(1 - (rho)^2)")
s <- matrix(c("p3.1 * x1^p4.1", e21, 0, e22), 2, 2)
slu <- jsonlite::fromJSON('{"start": {"p1.1": 1,"p2.1": 0.1,"p3.1": 0.1, "p4.1": 1, "p1.2": 1,"p2.2": 0.1,"p3.2": 0.1, "p4.2": 1}, "lower": {"p1.1": -100,"p2.1": 0,"p3.1": 0, "p4.1": 0, "p1.2": -100,"p2.2": 0,"p3.2": 0, "p4.2": 0}, "upper": {"p1.1": 100,"p2.1": 100,"p3.1": 100, "p4.1": 2, "p1.2": 100,"p2.2": 100,"p3.2": 100, "p4.1": 2}}')
sol <- c("x1", "x2")
# dX = sigma^2/2·(beta - gamma·X/Sqrt(delta^2 + (X - mu)^2)·dt + sigma·dW, Hyperbolic diffusion (dynamics of sand - the sand project, AAU); Iacus, 2011, Chicago R/Finance, April 29
} else if (model == "yhdf") {
b <- c("(p1.1^2)/2 * (p2.1 - p3.1 * x1 /sqrt(p4.1^2 + (x1 - p5.1)^2))", "(p1.2^2)/2 * (p2.2 - p3.2 * x2 /sqrt(p4.2^2 + (x2 - p5.2)^2))")
e21 <- gsub("rho", rho, "p1.2 * rho")
e22 <- gsub("rho", rho, "p1.2 * sqrt(1 - (rho)^2)")
s <- matrix(c("p1.1", e21, 0, e22), 2, 2)
slu <- jsonlite::fromJSON('{"start": {"p1.1": 0.1,"p2.1": 0.1,"p3.1": 0.1, "p4.1": 0.1, "p5.1": 0.1, "p1.2": 0.1,"p2.2": 0.1,"p3.2": 0.1, "p4.2": 0.1, "p5.1": 0.1}, "lower": {"p1.1": 0,"p2.1": -100,"p3.1": -1, "p4.1": 0, "p5.1": -100, "p1.2": 0,"p2.2": -100,"p3.2": -1, "p4.2": 0, "p5.1": -100}, "upper": {"p1.1": 1,"p2.1": 100,"p3.1": 1, "p4.1": 1, "p5.1": 100, "p1.2": 1,"p2.2": 100,"p3.2": 1, "p4.1": 1, "p5.1": 100}}')
sol <- c("x1", "x2")
}
return(list(drift = b, diffusion = s, solve.variable = sol, slu = slu))
}
funcor <- function(data, model = "you3", correlated = FALSE, start) {
p <- funparam(data, model, correlated)
if (missing(start)) {
start = p$slu$start
}
est <- riskbutlerRadar::yuima.qmle(log(data), delta = 1/365, drift = p$drift, diffusion = p$diffusion, solve.variable = p$solve.variable, method="L-BFGS-B", start = start, lower = p$slu$lower, upper = p$slu$upper, summary = FALSE)
return(est)
}
# -- multivariate simulations
# supply data without first taking log()
funsim <- function(data, model = "you3", correlated = FALSE) {
w <- 100
step <- 5
l <- sekvens(length(data[,1]), w, step)
# init (log) estimation
est <- funcor(data[seq(1, 1+w-1),], model, correlated)
est <- as.list(est@coef)
r <- foreach::foreach(i = l, .combine = rbind) %do% {
dat <- data[seq(i, i+w-1),]
est <- funcor(dat, model, correlated, est)
# To use estimates as start values in next or other qmle estimation set: start = as.list(res@coef)
est <- as.list(est@coef)
# ---
p <- funparam(data, model, correlated)
# risk time forecast approx. 7 days or 1 calendar week
sim <- riskbutlerRadar::yuima.simulate(setseed = FALSE, sumsim = FALSE, nsim = 2000, drift = p$drift, diffusion = p$diffusion, solve.variable = p$solve.variable, xinit = log(dat[w,]), Terminal = 1/52, n= 1, parameter = est)
sim <- exp(sim)
}
return(r)
}
sims <- funsim(xdata, model = "yckls", correlated = TRUE)
colnames(sims) <- c("CHF","SEK")
write.csv(as.table(sims), "./multisims-chan92.csv", row.names=FALSE)
sims <- funsim(xdata, model = "yhdf", correlated = FALSE)
colnames(sims) <- c("CHF","SEK")
write.csv(as.table(sims), "./unisims-hyperbolic.csv", row.names=FALSE)
funparam <- function(data, model = "you3", correlated = FALSE) {
rho <- 0
if (correlated == TRUE) {
rho <- cor(data)[2,1]
}
# dX = θ1·(θ2 - X)·dt + θ3·X·dW, Brennan & Schwartz 1980
if (model == "you3") {
b <- c("p1.1 * (p2.1 - x1)", "p1.2 * (p2.2 - x2)")
e21 <- gsub("rho", rho, "(p3.2 * x2) * rho")
e22 <- gsub("rho", rho, "(p3.2 * x2) * sqrt(1 - (rho)^2)")
s <- matrix(c("p3.1 * x1", e21, 0, e22), 2, 2)
slu <- jsonlite::fromJSON('{"start": {"p1.1": 1,"p2.1": 0.1,"p3.1": 0.1, "p1.2": 1,"p2.2": 0.1,"p3.2": 0.1}, "lower": {"p1.1": -100,"p2.1": 0,"p3.1": 0, "p1.2": -100,"p2.2": 0,"p3.2": 0}, "upper": {"p1.1": 100,"p2.1": 100,"p3.1": 100, "p1.2": 100,"p2.2": 100,"p3.2": 100}}')
sol <- c("x1", "x2")
# dX = θ1·(θ2 - X)·dt + θ3·X^θ4·dW, Chan-Karolyi-Longstaff-Sanders 1992
} else if (model == "yckls") {
b <- c("p1.1 * (p2.1 - x1)", "p1.2 * (p2.2 - x2)")
e21 <- gsub("rho", rho, "(p3.2 * x2^p4.2) * rho")
e22 <- gsub("rho", rho, "(p3.2 * x2^p4.2) * sqrt(1 - (rho)^2)")
s <- matrix(c("p3.1 * x1^p4.1", e21, 0, e22), 2, 2)
slu <- jsonlite::fromJSON('{"start": {"p1.1": 1,"p2.1": 0.1,"p3.1": 0.1, "p4.1": 1, "p1.2": 1,"p2.2": 0.1,"p3.2": 0.1, "p4.2": 1}, "lower": {"p1.1": -100,"p2.1": 0,"p3.1": 0, "p4.1": 0, "p1.2": -100,"p2.2": 0,"p3.2": 0, "p4.2": 0}, "upper": {"p1.1": 100,"p2.1": 100,"p3.1": 100, "p4.1": 2, "p1.2": 100,"p2.2": 100,"p3.2": 100, "p4.1": 2}}')
sol <- c("x1", "x2")
# dX = sigma^2/2·(beta - gamma·X/Sqrt(delta^2 + (X - mu)^2)·dt + sigma·dW, Hyperbolic diffusion (dynamics of sand - the sand project, AAU); Iacus, 2011, Chicago R/Finance, April 29
} else if (model == "yhdf") {
b <- c("(p1.1^2)/2 * (p2.1 - p3.1 * x1 /sqrt(p4.1^2 + (x1 - p5.1)^2))", "(p1.2^2)/2 * (p2.2 - p3.2 * x2 /sqrt(p4.2^2 + (x2 - p5.2)^2))")
e21 <- gsub("rho", rho, "p1.2 * rho")
e22 <- gsub("rho", rho, "p1.2 * sqrt(1 - (rho)^2)")
s <- matrix(c("p1.1", e21, 0, e22), 2, 2)
slu <- jsonlite::fromJSON('{"start": {"p1.1": 0.1,"p2.1": 0.1,"p3.1": 0.1, "p4.1": 0.1, "p5.1": 0.1, "p1.2": 0.1,"p2.2": 0.1,"p3.2": 0.1, "p4.2": 0.1, "p5.2": 0.1}, "lower": {"p1.1": 0,"p2.1": -100,"p3.1": -1, "p4.1": 0, "p5.1": -100, "p1.2": 0,"p2.2": -100,"p3.2": -1, "p4.2": 0, "p5.2": -100}, "upper": {"p1.1": 1,"p2.1": 100,"p3.1": 1, "p4.1": 1, "p5.1": 100, "p1.2": 1,"p2.2": 100,"p3.2": 1, "p4.1": 1, "p5.2": 100}}')
sol <- c("x1", "x2")
}
return(list(drift = b, diffusion = s, solve.variable = sol, slu = slu))
}
funparam <- function(data, model = "you3", correlated = FALSE) {
rho <- 0
if (correlated == TRUE) {
rho <- cor(data)[2,1]
}
# dX = θ1·(θ2 - X)·dt + θ3·X·dW, Brennan & Schwartz 1980
if (model == "you3") {
b <- c("p1.1 * (p2.1 - x1)", "p1.2 * (p2.2 - x2)")
e21 <- gsub("rho", rho, "(p3.2 * x2) * rho")
e22 <- gsub("rho", rho, "(p3.2 * x2) * sqrt(1 - (rho)^2)")
s <- matrix(c("p3.1 * x1", e21, 0, e22), 2, 2)
slu <- jsonlite::fromJSON('{"start": {"p1.1": 1,"p2.1": 0.1,"p3.1": 0.1, "p1.2": 1,"p2.2": 0.1,"p3.2": 0.1}, "lower": {"p1.1": -100,"p2.1": 0,"p3.1": 0, "p1.2": -100,"p2.2": 0,"p3.2": 0}, "upper": {"p1.1": 100,"p2.1": 100,"p3.1": 100, "p1.2": 100,"p2.2": 100,"p3.2": 100}}')
sol <- c("x1", "x2")
# dX = θ1·(θ2 - X)·dt + θ3·X^θ4·dW, Chan-Karolyi-Longstaff-Sanders 1992
} else if (model == "yckls") {
b <- c("p1.1 * (p2.1 - x1)", "p1.2 * (p2.2 - x2)")
e21 <- gsub("rho", rho, "(p3.2 * x2^p4.2) * rho")
e22 <- gsub("rho", rho, "(p3.2 * x2^p4.2) * sqrt(1 - (rho)^2)")
s <- matrix(c("p3.1 * x1^p4.1", e21, 0, e22), 2, 2)
slu <- jsonlite::fromJSON('{"start": {"p1.1": 1,"p2.1": 0.1,"p3.1": 0.1, "p4.1": 1, "p1.2": 1,"p2.2": 0.1,"p3.2": 0.1, "p4.2": 1}, "lower": {"p1.1": -100,"p2.1": 0,"p3.1": 0, "p4.1": 0, "p1.2": -100,"p2.2": 0,"p3.2": 0, "p4.2": 0}, "upper": {"p1.1": 100,"p2.1": 100,"p3.1": 100, "p4.1": 2, "p1.2": 100,"p2.2": 100,"p3.2": 100, "p4.1": 2}}')
sol <- c("x1", "x2")
# dX = sigma^2/2·(beta - gamma·X/Sqrt(delta^2 + (X - mu)^2)·dt + sigma·dW, Hyperbolic diffusion (dynamics of sand - the sand project, AAU); Iacus, 2011, Chicago R/Finance, April 29
} else if (model == "yhdf") {
b <- c("(p1.1^2)/2 * (p2.1 - p3.1 * x1 /sqrt(p4.1^2 + (x1 - p5.1)^2))", "(p1.2^2)/2 * (p2.2 - p3.2 * x2 /sqrt(p4.2^2 + (x2 - p5.2)^2))")
e21 <- gsub("rho", rho, "p1.2 * rho")
e22 <- gsub("rho", rho, "p1.2 * sqrt(1 - (rho)^2)")
s <- matrix(c("p1.1", e21, 0, e22), 2, 2)
slu <- jsonlite::fromJSON('{"start": {"p1.1": 0.1,"p2.1": 0.1,"p3.1": 0.1, "p4.1": 0.1, "p5.1": 0.1, "p1.2": 0.1,"p2.2": 0.1,"p3.2": 0.1, "p4.2": 0.1, "p5.2": 0.1}, "lower": {"p1.1": 0,"p2.1": -100,"p3.1": -1, "p4.1": 0, "p5.1": -100, "p1.2": 0,"p2.2": -100,"p3.2": -1, "p4.2": 0, "p5.2": -100}, "upper": {"p1.1": 1,"p2.1": 100,"p3.1": 1, "p4.1": 1, "p5.1": 100, "p1.2": 1,"p2.2": 100,"p3.2": 1, "p4.1": 1, "p5.2": 100}}')
sol <- c("x1", "x2")
}
return(list(drift = b, diffusion = s, solve.variable = sol, slu = slu))
}
sims <- funsim(xdata, model = "yhdf", correlated = FALSE)
colnames(sims) <- c("CHF","SEK")
write.csv(as.table(sims), "./unisims-hyperbolic.csv", row.names=FALSE)
sims2 <- funsim(xdata, model = "yhdf", correlated = TRUE)
colnames(sims2) <- c("CHF","SEK")
write.csv(as.table(sims2), "./multisims-hyperbolic.csv", row.names=FALSE)
# This is an implementation of a simulataneous estimation and simulation for two time series (can be expanded easily to n time series)
# Written by Sinan Gabel
# new ---
library(jsonlite)
library(yuima)
library(riskbutlerRadar)
library(foreach)
# - korreleret tidsserier
datalength <- 300
chf <- getData(request = list(class = "FX", base_currency = "DKK", currency = "CHF", frequency = "day", limit = datalength))
sek <- getData(request = list(class = "FX", base_currency = "DKK", currency = "SEK", frequency = "day", limit = datalength))
xdata <- data.frame(chf, sek)
write.csv(xdata, "./marketdata_daily_base_DKK.csv", row.names=FALSE)
cor(xdata)
plot(xdata)
# --
sekvens <- function(n, w, s) {
l <- seq(1, n - w + s, s)
if ((l[length(l)] + w - 1) > n ) {
l[length(l)] = n - w + 1
}
return(l)
}
l <- sekvens(datalength, 100, 10)
# --- multivariate estimations for dX
# new ---
library(jsonlite)
library(yuima)
library(riskbutlerRadar)
library(foreach)
datalength <- 300
chf <- getData(request = list(class = "FX", base_currency = "DKK", currency = "CHF", frequency = "day", limit = datalength))
sek <- getData(request = list(class = "FX", base_currency = "DKK", currency = "SEK", frequency = "day", limit = datalength))
xdata <- data.frame(chf, sek)
#write.csv(xdata, "./marketdata_daily_base_DKK.csv", row.names=FALSE)
cor(xdata)
plot(xdata)
sekvens <- function(n, w, s) {
l <- seq(1, n - w + s, s)
if ((l[length(l)] + w - 1) > n ) {
l[length(l)] = n - w + 1
}
return(l)
}
l <- sekvens(datalength, 100, 10)
funparam <- function(data, model = "you3", correlated = FALSE) {
rho <- 0
if (correlated == TRUE) {
rho <- cor(data)[2,1]
}
# dX = θ1·(θ2 - X)·dt + θ3·X·dW, Brennan & Schwartz 1980
if (model == "you3") {
b <- c("p1.1 * (p2.1 - x1)", "p1.2 * (p2.2 - x2)")
e21 <- gsub("rho", rho, "(p3.2 * x2) * rho")
e22 <- gsub("rho", rho, "(p3.2 * x2) * sqrt(1 - (rho)^2)")
s <- matrix(c("p3.1 * x1", e21, 0, e22), 2, 2)
slu <- jsonlite::fromJSON('{"start": {"p1.1": 1,"p2.1": 0.1,"p3.1": 0.1, "p1.2": 1,"p2.2": 0.1,"p3.2": 0.1}, "lower": {"p1.1": -100,"p2.1": 0,"p3.1": 0, "p1.2": -100,"p2.2": 0,"p3.2": 0}, "upper": {"p1.1": 100,"p2.1": 100,"p3.1": 100, "p1.2": 100,"p2.2": 100,"p3.2": 100}}')
sol <- c("x1", "x2")
# dX = θ1·(θ2 - X)·dt + θ3·X^θ4·dW, Chan-Karolyi-Longstaff-Sanders 1992
} else if (model == "yckls") {
b <- c("p1.1 * (p2.1 - x1)", "p1.2 * (p2.2 - x2)")
e21 <- gsub("rho", rho, "(p3.2 * x2^p4.2) * rho")
e22 <- gsub("rho", rho, "(p3.2 * x2^p4.2) * sqrt(1 - (rho)^2)")
s <- matrix(c("p3.1 * x1^p4.1", e21, 0, e22), 2, 2)
slu <- jsonlite::fromJSON('{"start": {"p1.1": 1,"p2.1": 0.1,"p3.1": 0.1, "p4.1": 1, "p1.2": 1,"p2.2": 0.1,"p3.2": 0.1, "p4.2": 1}, "lower": {"p1.1": -100,"p2.1": 0,"p3.1": 0, "p4.1": 0, "p1.2": -100,"p2.2": 0,"p3.2": 0, "p4.2": 0}, "upper": {"p1.1": 100,"p2.1": 100,"p3.1": 100, "p4.1": 2, "p1.2": 100,"p2.2": 100,"p3.2": 100, "p4.1": 2}}')
sol <- c("x1", "x2")
# dX = sigma^2/2·(beta - gamma·X/Sqrt(delta^2 + (X - mu)^2)·dt + sigma·dW, Hyperbolic diffusion (dynamics of sand - the sand project, AAU); Iacus, 2011, Chicago R/Finance, April 29
} else if (model == "yhdf") {
b <- c("(p1.1^2)/2 * (p2.1 - p3.1 * x1 /sqrt(p4.1^2 + (x1 - p5.1)^2))", "(p1.2^2)/2 * (p2.2 - p3.2 * x2 /sqrt(p4.2^2 + (x2 - p5.2)^2))")
e21 <- gsub("rho", rho, "p1.2 * rho")
e22 <- gsub("rho", rho, "p1.2 * sqrt(1 - (rho)^2)")
s <- matrix(c("p1.1", e21, 0, e22), 2, 2)
slu <- jsonlite::fromJSON('{"start": {"p1.1": 0.1,"p2.1": 0.1,"p3.1": 0.1, "p4.1": 0.1, "p5.1": 0.1, "p1.2": 0.1,"p2.2": 0.1,"p3.2": 0.1, "p4.2": 0.1, "p5.2": 0.1}, "lower": {"p1.1": 0,"p2.1": -100,"p3.1": -1, "p4.1": 0, "p5.1": -100, "p1.2": 0,"p2.2": -100,"p3.2": -1, "p4.2": 0, "p5.2": -100}, "upper": {"p1.1": 1,"p2.1": 100,"p3.1": 1, "p4.1": 1, "p5.1": 100, "p1.2": 1,"p2.2": 100,"p3.2": 1, "p4.1": 1, "p5.2": 100}}')
sol <- c("x1", "x2")
}
return(list(drift = b, diffusion = s, solve.variable = sol, slu = slu))
}
funcor <- function(data, model = "you3", correlated = FALSE, start) {
p <- funparam(data, model, correlated)
if (missing(start)) {
start = p$slu$start
}
est <- riskbutlerRadar::yuima.qmle(log(data), delta = 1/365, drift = p$drift, diffusion = p$diffusion, solve.variable = p$solve.variable, method="L-BFGS-B", start = start, lower = p$slu$lower, upper = p$slu$upper, summary = FALSE)
return(est)
}
sys.time(funcor(xdata))
sys.time()
Sys.time(funcor(xdata))
proc.time
proc.time()
ptm <- proc.time()
ptm <- proc.time(); funcor(xdata); proc.time() - ptm
ptm <- proc.time(); funcor(xdata); proc.time() - ptm
ptm <- proc.time()
aiUpdown()
proc.time() - ptm
library(riskbutlerRadar)
library(riskbutlerRadar)
library(riskbutlerRadar)
library(riskbutlerRadar)
aiUpdown <- function(result, ...) {
if (missing(result)) {
result <- jsonlite::fromJSON('{"parameters": {"activity_financial": "import", "amount_currency": {"amount": 100, "currency": "GBP"}, "base_currency": "DKK", "date": "2017-12-10"}}')
}
api <- result$parameters
# temporary
base_currency <- api$base_currency
currency <- api$amount_currency$currency
if (base_currency == currency) {
txt <- jsonlite::unbox("There is no foreign exchange risk on your activity because the base currency and activity currency are the same. To understand how this was calculated please go to riskbutler.com.")
} else {
## . Check if results are already calculated and stored, else make new simulations; check if result and all parameters are there and correct;
## . Get market data
# tip: preload httr in opencpu
# tip: add date to fields to see actual data time stamps, and add verbose() to the POST parameters for more info on the call
# todo: filter weekend data out; check if a result is returned; test with lasso if model 3 is appropriate or perhaps a simpler model can be used e.g. where p4=1 <=> Brennan 92
freq <- "hour"
xdata <- riskbutlerRadar::getData(request = list(class = "FX", base_currency = base_currency, currency = currency, frequency = freq, limit = 252))
## . Estimate parameters
if (freq == "hour") {
delta = 1/(365*24)
} else {
delta = 1/365
}
nsim <- 10000
sims <- riskbutlerRadar::simulate_all(xdata, T = 1/52, nsim = nsim, delta = delta)
xinit <- xdata[length(xdata)]
## Make wanted statistics
sims <- sort(sims)
q <- 0.01
up <- (sims[round((1-q) * nsim)] - xinit)/xinit  # q * 100 percent chance of up = up, or more up
down <- (sims[round(q * nsim)] - xinit)/xinit    # q * 100 percent chance of down = down, or further down
## Save results to db for next user
## Return forecast info to api.ai
txt <- jsonlite::unbox(paste("The chance of profit is", format(up * 100, digits = 2), "percent, and the risk of loss is", format(down * 100, digits = 2), " percent of your", api$activity_financial, "activity amount. To understand how this was calculated please go to riskbutler.com."))
}
return(list(speech = txt, displayText = txt, source = jsonlite::unbox("riskbutler.net")))
}
dd <- jsonlite::fromJSON('{"parameters": {"activity_financial": "import", "amount_currency": {"amount": 100, "currency": "GBP"}, "base_currency": "DKK", "date": "2017-12-10"}}')
dd
aiUpdown(dd)
yuima.qmle.seq <- function(data, window = 100, step = 10, delta = 1/252, summary = TRUE, drift, diffusion, hurst = 0.5, solve.variable = "x", start, ...) {
ymod <- yuima::setModel(drift = drift, diffusion = diffusion, hurst = hurst, solve.variable = solve.variable, state.variable = solve.variable)
#
sekvens <- function(n, w, s) {
l <- seq(1, n - w + s, s)
if ((l[length(l)] + w - 1) > n ) {
l[length(l)] = n - w + 1
}
return(l)
}
# check for multivariate model
if (length(drift) > 1) {
multi = TRUE
} else {
multi = FALSE
}
# check foreach further: even, uneven indexes; vector or matrix etc.
w <- window
#step <- 10
if (multi == FALSE) {
n <- length(data)
} else {
n <- length(data[,1])
}
#l <- seq(1, n - w + step, step)
l <- sekvens(n, w, step)
est = start
# parallel %dopar% or %do%
#r <- foreach::foreach(i=l, .combine = cbind, .packages="foreach") %do% {
r <- foreach::foreach(i = l, .combine = cbind) %do% {
if (multi == FALSE) {
dat <- data[seq(i, i+w-1)]
} else {
dat <- data[seq(i, i+w-1),]
}
dat <- yuima::setData(dat, delta = delta)
yobj <- yuima::setYuima(model = ymod, data = dat)
res <- yuima::qmle(yobj, start = est, ...)
# To use estimates as start values in next or other qmle estimation set: start = as.list(res@coef)
est <- as.list(res@coef)
res@coef
}
if (summary == TRUE)
#return(jsonlite::toJSON(list( call = list(seq = l, w = w, step = step, n = n), coef = as.data.frame(t(r)))))
return(list( call = list(seq = l, w = w, step = step, n = n), coef = as.data.frame(t(r))))
else
return(r)
}
yuima.qmle.seq <- function(data, window = 100, step = 10, delta = 1/252, summary = TRUE, drift, diffusion, hurst = 0.5, solve.variable = "x", start, ...) {
ymod <- yuima::setModel(drift = drift, diffusion = diffusion, hurst = hurst, solve.variable = solve.variable, state.variable = solve.variable)
#
sekvens <- function(n, w, s) {
l <- seq(1, n - w + s, s)
if ((l[length(l)] + w - 1) > n ) {
l[length(l)] = n - w + 1
}
return(l)
}
# check for multivariate model
if (length(drift) > 1) {
multi = TRUE
} else {
multi = FALSE
}
# check foreach further: even, uneven indexes; vector or matrix etc.
w <- window
#step <- 10
if (multi == FALSE) {
n <- length(data)
} else {
n <- length(data[,1])
}
#l <- seq(1, n - w + step, step)
l <- sekvens(n, w, step)
est = start
# parallel %dopar% or %do%
#r <- foreach::foreach(i=l, .combine = cbind, .packages="foreach") %do% {
r <- foreach::foreach(i = l, .combine = cbind) %do% {
if (multi == FALSE) {
dat <- data[seq(i, i+w-1)]
} else {
dat <- data[seq(i, i+w-1),]
}
dat <- yuima::setData(dat, delta = delta)
yobj <- yuima::setYuima(model = ymod, data = dat)
res <- yuima::qmle(yobj, start = est, ...)
# To use estimates as start values in next or other qmle estimation set: start = as.list(res@coef)
est <- as.list(res@coef)
res@coef
}
if (summary == TRUE)
#return(jsonlite::toJSON(list( call = list(seq = l, w = w, step = step, n = n), coef = as.data.frame(t(r)))))
return(list( call = list(seq = l, w = w, step = step, n = n), coef = as.data.frame(t(r))))
else
return(r)
}
library(riskbutlerRadar)
aiUpdown(dd)
library(riskbutlerRadar)
library(riskbutlerRadar)
dd <- jsonlite::fromJSON('{"parameters": {"activity_financial": "import", "amount_currency": {"amount": 100, "currency": "GBP"}, "base_currency": "DKK", "date": "2017-12-10"}}')
aiUpdown(dd)
dd <- jsonlite::fromJSON('{"parameters": {"activity_financial": "import", "amount_currency": {"amount": 100, "currency": "GBP"}, "base_currency": "GBP", "date": "2017-12-10"}}')
aiUpdown(dd)
library(riskbutlerRadar)
library(riskbutlerRadar)
dd <- jsonlite::fromJSON('{"parameters": {"activity_financial": "import", "amount_currency": {"amount": 100, "currency": "GBP"}, "base_currency": "GBP", "date": "2017-12-10"}}')
aiUpdown(dd)
aiUpdown(dd)
library(riskbutlerRadar)
library(riskbutlerRadar)
dd <- jsonlite::fromJSON('{"parameters": {"activity_financial": "import", "amount_currency": {"amount": 100, "currency": "GBP"}, "base_currency": "GBP", "date": "2017-12-10"}}')
aiUpdown(dd)
library(riskbutlerRadar)
dd <- jsonlite::fromJSON('{"parameters": {"activity_financial": "import", "amount_currency": {"amount": 100, "currency": "GBP"}, "base_currency": "GBP", "date": "2017-12-10"}}')
aiUpdown(dd)
paste("Hi","Albertine")
paste("Hi","Albertine",sep="")
library(riskbutlerRadar)
dd <- jsonlite::fromJSON('{"parameters": {"activity_financial": "import", "amount_currency": {"amount": 100, "currency": "GBP"}, "base_currency": "GBP", "date": "2017-12-10"}}')
paste("Hi","Albertine",sep="")
aiUpdown(dd)
dd <- jsonlite::fromJSON('{"parameters": {"activity_financial": "import", "amount_currency": {"amount": 100, "currency": "GBP"}, "base_currency": "USD", "date": "2017-12-10"}}')
aiUpdown(dd)
library(riskbutlerRadar)
aiUpdown(jsonlite::fromJSON('{"parameters": {"activity_financial": "import", "amount_currency": {"amount": 100, "currency": "GBP"}, "base_currency": "DKK", "date": "2017-12-10"}}'))
library(riskbutlerRadar)
aiUpdown(jsonlite::fromJSON('{"parameters": {"activity_financial": "import", "amount_currency": {"amount": 100, "currency": "GBP"}, "base_currency": "DKK", "date": "2017-12-10"}}'))
library(riskbutlerRadar)
aiUpdown(jsonlite::fromJSON('{"parameters": {"activity_financial": "import", "amount_currency": {"amount": 100, "currency": "GBP"}, "base_currency": "DKK", "date": "2017-12-10"}}'))
aiUpdown(jsonlite::fromJSON('{"parameters": {"activity_financial": "export", "amount_currency": {"amount": 100, "currency": "GBP"}, "base_currency": "DKK", "date": "2017-12-10"}}'))
aiUpdown(jsonlite::fromJSON('{"parameters": {"activity_financial": "export", "amount_currency": {"amount": 100, "currency": "GBP"}, "base_currency": "DKK", "date": "2017-12-10"}}'))
aiUpdown(jsonlite::fromJSON('{"parameters": {"activity_financial": "invest", "amount_currency": {"amount": 100, "currency": "GBP"}, "base_currency": "DKK", "date": "2017-12-10"}}'))
library(riskbutlerRadar)
aiUpdown(jsonlite::fromJSON('{"parameters": {"activity_financial": "invest", "amount_currency": {"amount": 100, "currency": "GBP"}, "base_currency": "DKK", "date": "2017-12-10"}}'))
aiUpdown(jsonlite::fromJSON('{"parameters": {"activity_financial": "import", "amount_currency": {"amount": 100, "currency": "GBP"}, "base_currency": "DKK", "date": "2017-12-10"}}'))
aiUpdown(jsonlite::fromJSON('{"parameters": {"activity_financial": "trade", "amount_currency": {"amount": 100, "currency": "GBP"}, "base_currency": "DKK", "date": "2017-12-10"}}'))
aiUpdown(jsonlite::fromJSON('{"parameters": {"activity_financial": "trade", "amount_currency": {"amount": 100, "currency": "EUR"}, "base_currency": "DKK", "date": "2017-12-10"}}'))
aiUpdown(jsonlite::fromJSON('{"parameters": {"activity_financial": "trade", "amount_currency": {"amount": 100, "currency": "EUR"}, "base_currency": "DKK", "date": "2017-12-10"}}'))
dd <- aiUpdown(jsonlite::fromJSON('{"parameters": {"activity_financial": "export", "amount_currency": {"amount": 100, "currency": "EUR"}, "base_currency": "DKK", "date": "2017-12-10"}}'))
dd <- getData(request = list(class = "FX", base_currency = "DKK", currency = "EUR", frequency = "hour", limit = 100))
plot(dd, type="b")
dd <- getData(request = list(class = "FX", base_currency = "DKK", currency = "EUR", frequency = "day", limit = 100))
plot(dd, type="b")
sims <- riskbutlerRadar::simulate_all(dd, T = 1/12, nsim = 10000, delta = 1/365, estimations = 1)
plot(sort(sims))
hist(sims)
sims <- riskbutlerRadar::simulate_all(dd, T = 1/12, nsim = 10000, delta = 1/365, estimations = 5)
hist(sims)
sims <- riskbutlerRadar::simulate_all(dd, T = 1/12, nsim = 10000, delta = 1/365, estimations = 2)
hist(sims)
sims <- riskbutlerRadar::simulate_all(dd, T = 1/12, nsim = 10000, delta = 1/365, estimations = 3)
hist(sims)
sims <- riskbutlerRadar::simulate_all(dd, T = 1/12, nsim = 10000, delta = 1/365, estimations = 4)
hist(sims)
sims <- riskbutlerRadar::simulate_all(dd, T = 1/12, nsim = 10000, delta = 1/365, estimations = 5)
hist(sims)
7.44/7.35
library(riskbutlerRadar)
dd <- getData(request = list(class = "FX", base_currency = "DKK", currency = "EUR", frequency = "day", limit = 100))
plot(dd, type="b")
sims <- riskbutlerRadar::simulate_all(dd, T = 1/12, nsim = 10000, delta = 1/365, estimations = 1)
hist(dd)
sims <- riskbutlerRadar::simulate_all(dd, T = 1/12, nsim = 10000, delta = 1/365, estimations = 5)
hist(dd)
sims <- riskbutlerRadar::simulate_all(dd, T = 1/12, nsim = 10000, delta = 1/365, estimations = 1)
hist(dd)
library(riskbutlerRadar)
aiUpdown(jsonlite::fromJSON('{"parameters": {"activity_financial": "import", "amount_currency": {"amount": 100, "currency": "GBP"}, "base_currency": "DKK", "date": "2017-12-10"}}'))
aiUpdown(jsonlite::fromJSON('{"parameters": {"activity_financial": "import", "amount_currency": {"amount": 100, "currency": "EUR"}, "base_currency": "DKK", "date": "2017-12-10"}}'))
library(riskbutlerRadar)
library(riskbutlerRadar)
aiUpdown(jsonlite::fromJSON('{"parameters": {"activity_financial": "import", "amount_currency": {"amount": 100, "currency": "EUR"}, "base_currency": "DKK", "date": "2017-12-10"}}'))
dd <- getData(request = list(class = "FX", base_currency = "DKK", currency = "EUR", frequency = "day", limit = 100))
plot(dd, type="b")
sims <- riskbutlerRadar::simulate_all(dd, T = 1/12, nsim = 10000, delta = 1/365, estimations = 1)
hist(sims)
?print
library(riskbutlerRadar)
sims <- riskbutlerRadar::simulate_all(dd, T = 1/12, nsim = 10000, delta = 1/365, estimations = 1)
hist(sims)
sims <- riskbutlerRadar::simulate_all(dd, T = 1/12, nsim = 10000, delta = 1/365, estimations = 3); hist(sims)
sims <- riskbutlerRadar::simulate_all(dd, T = 1/12, nsim = 10000, delta = 1/365, estimations = 5); hist(sims)
sims <- riskbutlerRadar::simulate_all(dd, T = 1/12, nsim = 10000, delta = 1/365, estimations = 2); hist(sims)
sims <- riskbutlerRadar::simulate_all(dd, T = 1/12, nsim = 10000, delta = 1/365, estimations = 1); hist(sims)
library(riskbutlerRadar)
aiUpdown(jsonlite::fromJSON('{"parameters": {"activity_financial": "import", "amount_currency": {"amount": 100, "currency": "EUR"}, "base_currency": "DKK", "date": "2017-12-10"}}'))
aiUpdown(jsonlite::fromJSON('{"parameters": {"activity_financial": "import", "amount_currency": {"amount": 100, "currency": "EUR"}, "base_currency": "DKK", "date": "2017-12-10"}}'))
ptm <- proc.time(); aiUpdown(jsonlite::fromJSON('{"parameters": {"activity_financial": "import", "amount_currency": {"amount": 100, "currency": "EUR"}, "base_currency": "DKK", "date": "2017-12-10"}}')); proc.time() - ptm
ptm <- proc.time(); aiUpdown(jsonlite::fromJSON('{"parameters": {"activity_financial": "import", "amount_currency": {"amount": 100, "currency": "CHF"}, "base_currency": "DKK", "date": "2017-12-10"}}')); proc.time() - ptm
ptm <- proc.time(); aiUpdown(jsonlite::fromJSON('{"parameters": {"activity_financial": "import", "amount_currency": {"amount": 100, "currency": "EUR"}, "base_currency": "DKK", "date": "2017-12-10"}}')); proc.time() - ptm
ptm <- proc.time(); aiUpdown(jsonlite::fromJSON('{"parameters": {"activity_financial": "import", "amount_currency": {"amount": 100, "currency": "EUR"}, "base_currency": "USD", "date": "2017-12-10"}}')); proc.time() - ptm
ptm <- proc.time(); aiUpdown(jsonlite::fromJSON('{"parameters": {"activity_financial": "import", "amount_currency": {"amount": 100, "currency": "DKK"}, "base_currency": "EUR", "date": "2017-12-10"}}')); proc.time() - ptm
ptm <- proc.time(); aiUpdown(jsonlite::fromJSON('{"parameters": {"activity_financial": "import", "amount_currency": {"amount": 100, "currency": "EUR"}, "base_currency": "DKK", "date": "2017-12-10"}}')); proc.time() - ptm
ptm <- proc.time(); aiUpdown(jsonlite::fromJSON('{"parameters": {"activity_financial": "import", "amount_currency": {"amount": 100, "currency": "EUR"}, "base_currency": "DKK", "date": "2017-12-10"}}')); proc.time() - ptm
ptm <- proc.time(); aiUpdown(jsonlite::fromJSON('{"parameters": {"activity_financial": "import", "amount_currency": {"amount": 100, "currency": "EUR"}, "base_currency": "DKK", "date": "2017-12-10"}}')); proc.time() - ptm
library(riskbutlerRadar)
library(riskbutlerRadar)
library(riskbutlerRadar)
