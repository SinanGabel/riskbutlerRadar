body <- list(selector = list("_id" = list("$gt" = "a"), "type" = "hour"), fields = fields, limit = 300, sort = fromJSON('[{"_id": "desc"}]'))
tt <- 365*24  # hourly data
T <- 1/52     # one week => use sqrt of time rule for (shorter) longer risk time horisons
## . Get market data
# tip: preload httr in opencpu
# tip: add date to fields to see actual data time stamps, and add verbose() to the POST parameters for more info on the call
# todo: filter weekend data out; check if a result is returned;
r <- POST("https://riskbutler.net/fx1/_find", body = body, encode = "json")
proc.time() - ptm
## . Transform data
ptm <- proc.time()
rates <- fromJSON(rawToChar(r$content), flatten = TRUE)
xdata <- rev(rates$docs[,1]/rates$docs[,2])
proc.time() - ptm
## . Estimate parameters
# ycks model 3
ptm <- proc.time()
js <- fromJSON('{"start": {"p1": 1,"p2": 0.1,"p3": 0.1,"p4": 1}, "lower": {"p1": -100,"p2": 0,"p3": 0,"p4": 0}, "upper": {"p1": 100,"p2": 100,"p3": 1,"p4": 2}}')
win_less <- 4
qmle_step <- 2
est <- yuima.qmle.seq(data = log(xdata), window = length(xdata) - win_less, step = qmle_step, delta = 1/tt, drift = "p1 * (p2 - x)", diffusion = "p3 * x^p4", hurst = 0.5, solve.variable = "x", method="L-BFGS-B",  start = js$start, lower = js$lower, upper = js$upper)
proc.time() - ptm
## . Simulate
ptm <- proc.time()
coef_i <- win_less/qmle_step + 1
nsim <- 1000
xinit <- xdata[length(xdata)]
sims <- exp(eulerOne(xinit = log(xinit), Terminal = T, nsim = nsim, parameter = list(p1 =est$coef$p1[coef_i], p2 = est$coef$p2[coef_i], p3 = est$coef$p3[coef_i], p4 = est$coef$p4[coef_i])))
proc.time() - ptm
## Make wanted statistics
sims <- sort(sims)
q <- 0.01
up <- (sims[round((1-q) * nsim)] - xinit)/xinit  # q * 100 percent chance of up = up, or more up
down <- (sims[round(q * nsim)] - xinit)/xinit    # q * 100 percent chance of down = down, or further down
ptm <- proc.time()
base_currency <- "DKK"
currency <- "GBP"
fields <- c(paste("new.", base_currency, sep=""), paste("new.", currency, sep=""))
body <- list(selector = list("_id" = list("$gt" = "a"), "type" = "hour"), fields = fields, limit = 300, sort = fromJSON('[{"_id": "desc"}]'))
tt <- 365*24  # hourly data
T <- 1/52     # one week => use sqrt of time rule for (shorter) longer risk time horisons
## . Get market data
# tip: preload httr in opencpu
# tip: add date to fields to see actual data time stamps, and add verbose() to the POST parameters for more info on the call
# todo: filter weekend data out; check if a result is returned;
r <- POST("https://riskbutler.net/fx1/_find", body = body, encode = "json")
## . Transform data
rates <- fromJSON(rawToChar(r$content), flatten = TRUE)
xdata <- rev(rates$docs[,1]/rates$docs[,2])
## . Estimate parameters
# ycks model 3
js <- fromJSON('{"start": {"p1": 1,"p2": 0.1,"p3": 0.1,"p4": 1}, "lower": {"p1": -100,"p2": 0,"p3": 0,"p4": 0}, "upper": {"p1": 100,"p2": 100,"p3": 1,"p4": 2}}')
win_less <- 4
qmle_step <- 2
est <- yuima.qmle.seq(data = log(xdata), window = length(xdata) - win_less, step = qmle_step, delta = 1/tt, drift = "p1 * (p2 - x)", diffusion = "p3 * x^p4", hurst = 0.5, solve.variable = "x", method="L-BFGS-B",  start = js$start, lower = js$lower, upper = js$upper)
## . Simulate
coef_i <- win_less/qmle_step + 1
nsim <- 1000
xinit <- xdata[length(xdata)]
sims <- exp(eulerOne(xinit = log(xinit), Terminal = T, nsim = nsim, parameter = list(p1 =est$coef$p1[coef_i], p2 = est$coef$p2[coef_i], p3 = est$coef$p3[coef_i], p4 = est$coef$p4[coef_i])))
## Make wanted statistics
sims <- sort(sims)
q <- 0.01
up <- (sims[round((1-q) * nsim)] - xinit)/xinit  # q * 100 percent chance of up = up, or more up
down <- (sims[round(q * nsim)] - xinit)/xinit    # q * 100 percent chance of down = down, or further down
## Save results to db for next user
proc.time() - ptm
## Return forecast info to api.ai
ptm <- proc.time()
base_currency <- "SEK"
currency <- "GBP"
fields <- c(paste("new.", base_currency, sep=""), paste("new.", currency, sep=""))
body <- list(selector = list("_id" = list("$gt" = "a"), "type" = "hour"), fields = fields, limit = 300, sort = fromJSON('[{"_id": "desc"}]'))
tt <- 365*24  # hourly data
T <- 1/52     # one week => use sqrt of time rule for (shorter) longer risk time horisons
## . Get market data
# tip: preload httr in opencpu
# tip: add date to fields to see actual data time stamps, and add verbose() to the POST parameters for more info on the call
# todo: filter weekend data out; check if a result is returned;
r <- POST("https://riskbutler.net/fx1/_find", body = body, encode = "json")
## . Transform data
rates <- fromJSON(rawToChar(r$content), flatten = TRUE)
xdata <- rev(rates$docs[,1]/rates$docs[,2])
## . Estimate parameters
# ycks model 3
js <- fromJSON('{"start": {"p1": 1,"p2": 0.1,"p3": 0.1,"p4": 1}, "lower": {"p1": -100,"p2": 0,"p3": 0,"p4": 0}, "upper": {"p1": 100,"p2": 100,"p3": 1,"p4": 2}}')
win_less <- 4
qmle_step <- 2
est <- yuima.qmle.seq(data = log(xdata), window = length(xdata) - win_less, step = qmle_step, delta = 1/tt, drift = "p1 * (p2 - x)", diffusion = "p3 * x^p4", hurst = 0.5, solve.variable = "x", method="L-BFGS-B",  start = js$start, lower = js$lower, upper = js$upper)
## . Simulate
coef_i <- win_less/qmle_step + 1
nsim <- 1000
xinit <- xdata[length(xdata)]
sims <- exp(eulerOne(xinit = log(xinit), Terminal = T, nsim = nsim, parameter = list(p1 =est$coef$p1[coef_i], p2 = est$coef$p2[coef_i], p3 = est$coef$p3[coef_i], p4 = est$coef$p4[coef_i])))
## Make wanted statistics
sims <- sort(sims)
q <- 0.01
up <- (sims[round((1-q) * nsim)] - xinit)/xinit  # q * 100 percent chance of up = up, or more up
down <- (sims[round(q * nsim)] - xinit)/xinit    # q * 100 percent chance of down = down, or further down
## Save results to db for next user
proc.time() - ptm
## Return forecast info to api.ai
ptm <- proc.time()
base_currency <- "SEK"
currency <- "GBP"
fields <- c(paste("new.", base_currency, sep=""), paste("new.", currency, sep=""))
body <- list(selector = list("_id" = list("$gt" = "a"), "type" = "hour"), fields = fields, limit = 300, sort = fromJSON('[{"_id": "desc"}]'))
tt <- 365*24  # hourly data
T <- 1/52     # one week => use sqrt of time rule for (shorter) longer risk time horisons
## . Get market data
# tip: preload httr in opencpu
# tip: add date to fields to see actual data time stamps, and add verbose() to the POST parameters for more info on the call
# todo: filter weekend data out; check if a result is returned;
r <- POST("https://riskbutler.net/fx1/_find", body = body, encode = "json")
## . Transform data
rates <- fromJSON(rawToChar(r$content), flatten = TRUE)
xdata <- rev(rates$docs[,1]/rates$docs[,2])
## . Estimate parameters
# ycks model 3
js <- fromJSON('{"start": {"p1": 1,"p2": 0.1,"p3": 0.1,"p4": 1}, "lower": {"p1": -100,"p2": 0,"p3": 0,"p4": 0}, "upper": {"p1": 100,"p2": 100,"p3": 1,"p4": 2}}')
win_less <- 4
qmle_step <- 2
est <- yuima.qmle.seq(data = log(xdata), window = length(xdata) - win_less, step = qmle_step, delta = 1/tt, drift = "p1 * (p2 - x)", diffusion = "p3 * x^p4", hurst = 0.5, solve.variable = "x", method="L-BFGS-B",  start = js$start, lower = js$lower, upper = js$upper)
## . Simulate
coef_i <- win_less/qmle_step + 1
nsim <- 1000
xinit <- xdata[length(xdata)]
sims <- exp(eulerOne(xinit = log(xinit), Terminal = T, nsim = nsim, parameter = list(p1 =est$coef$p1[coef_i], p2 = est$coef$p2[coef_i], p3 = est$coef$p3[coef_i], p4 = est$coef$p4[coef_i])))
## Make wanted statistics
sims <- sort(sims)
q <- 0.01
up <- (sims[round((1-q) * nsim)] - xinit)/xinit  # q * 100 percent chance of up = up, or more up
down <- (sims[round(q * nsim)] - xinit)/xinit    # q * 100 percent chance of down = down, or further down
## Save results to db for next user
proc.time() - ptm
## Return forecast info to api.ai
up
down
plot(xdata)
mean(sims)
xdata[-1]
xdata[3002]
xdata[length(xdata)]
86400000/24
request = list(class = "FX", base_currency = "EUR", currency = "USD", frequency = , limit = 100)
request = list(class = "FX", base_currency = "EUR", currency = "USD", frequency = "hour", limit = 100)
request$frequency
1==1
1==8
getData <- function(request = list(class = "FX", base_currency = "EUR", currency = "USD", frequency = "day", limit = 100)) {
## . Get market data
# tip: preload httr in opencpu
# tip: add date to fields to see actual data time stamps, and add verbose() to the POST parameters for more info on the call
# todo: filter weekend data out; check if a result is returned; test with lasso if model 3 is appropriate or perhaps a simpler model can be used e.g. where p4=1 <=> Brennan 92
fields <- c(paste("new.", request$base_currency, sep=""), paste("new.", request$currency, sep=""))
if (frequency == "day") {
sel <- list("_id" = list("$gt" = "a"), "type" = "hour", "date.3" = 18)
} else {
sel <- list("_id" = list("$gt" = "a"), "type" = "hour")
}
body <- list(selector = sel, fields = fields, limit = request$limit, sort = fromJSON('[{"_id": "desc"}]'))
tt <- 365  # hourly data => use daily data instead?
T <- 1/52  # one week => use sqrt of time rule for (shorter) longer risk time horisons
r <- POST("https://riskbutler.net/fx1/_find", body = body, encode = "json")
## . Transform data
rates <- fromJSON(rawToChar(r$content), flatten = TRUE)
xdata <- rev(rates$docs[,1]/rates$docs[,2])
return(xdata)
}
getData(request = list(class = "FX", base_currency = "DKK", currency = "GBP", frequency = "day", limit = 100))
getData <- function(request = list(class = "FX", base_currency = "EUR", currency = "USD", frequency = "day", limit = 100)) {
## . Get market data
# tip: preload httr in opencpu
# tip: add date to fields to see actual data time stamps, and add verbose() to the POST parameters for more info on the call
# todo: filter weekend data out; check if a result is returned; test with lasso if model 3 is appropriate or perhaps a simpler model can be used e.g. where p4=1 <=> Brennan 92
fields <- c(paste("new.", request$base_currency, sep=""), paste("new.", request$currency, sep=""))
if (request$frequency == "day") {
sel <- list("_id" = list("$gt" = "a"), "type" = "hour", "date.3" = 18)
} else {
sel <- list("_id" = list("$gt" = "a"), "type" = "hour")
}
body <- list(selector = sel, fields = fields, limit = request$limit, sort = fromJSON('[{"_id": "desc"}]'))
r <- POST("https://riskbutler.net/fx1/_find", body = body, encode = "json")
## . Transform data
rates <- fromJSON(rawToChar(r$content), flatten = TRUE)
xdata <- rev(rates$docs[,1]/rates$docs[,2])
return(xdata)
}
getData(request = list(class = "FX", base_currency = "DKK", currency = "GBP", frequency = "day", limit = 100))
getData(request = list(class = "FX", base_currency = "USD", currency = "USD", frequency = "day", limit = 100))
?seq
seq.int(10)
rep.int(x,2)
rep.int(3,2)
rep.int(1,20)
length(rep.int(1,20))
getData <- function(request = list(class = "FX", base_currency = "EUR", currency = "USD", frequency = "day", limit = 100)) {
if (request$class == "FX") {
if (request$base_currency == request$currency) {
return(rep.int(1, request$limit))
}
## . Get market data
# tip: preload httr in opencpu
# tip: add date to fields to see actual data time stamps, and add verbose() to the POST parameters for more info on the call
# todo: filter weekend data out; check if a result is returned; test with lasso if model 3 is appropriate or perhaps a simpler model can be used e.g. where p4=1 <=> Brennan 92
fields <- c(paste("new.", request$base_currency, sep=""), paste("new.", request$currency, sep=""))
if (request$frequency == "day") {
sel <- list("_id" = list("$gt" = "a"), "type" = "hour", "date.3" = 18)
} else {
sel <- list("_id" = list("$gt" = "a"), "type" = "hour")
}
body <- list(selector = sel, fields = fields, limit = request$limit, sort = fromJSON('[{"_id": "desc"}]'))
r <- POST("https://riskbutler.net/fx1/_find", body = body, encode = "json")
## . Transform data
rates <- fromJSON(rawToChar(r$content), flatten = TRUE)
xdata <- rev(rates$docs[,1]/rates$docs[,2])
}
return(xdata)
}
getData(request = list(class = "FX", base_currency = "DKK", currency = "GBP", frequency = "day", limit = 100))
getData(request = list(class = "FX", base_currency = "USD", currency = "USD", frequency = "day", limit = 100))
getData(request = list(class = "FX", base_currency = "EUR", currency = "USD", frequency = "day", limit = 100))
getData(request = list(class = "FX", base_currency = "USD", currency = "EUR", frequency = "day", limit = 100))
dd <- getData(request = list(class = "FX", base_currency = "USD", currency = "EUR", frequency = "day", limit = 100))
plot(dd)
dd <- getData(request = list(class = "FX", base_currency = "USD", currency = "EUR", frequency = "hour", limit = 100))
plot(dd)
dd <- getData(request = list(class = "FX", base_currency = "USD", currency = "EUR", frequency = "day", limit = 100))
plot(dd)
ptm <- proc.time()
dd <- getData(request = list(class = "FX", base_currency = "USD", currency = "EUR", frequency = "day", limit = 100))
proc.time() - ptm
ptm <- proc.time()
dd <- getData(request = list(class = "FX", base_currency = "USD", currency = "EUR", frequency = "hour", limit = 100))
proc.time() - ptm
plot(dd)
typeof(dd)
?numeric
?return
simulate.all <- function(data, T = 1, nsim = 100, delta = 1/252)  {
## . Estimate parameters
# ycks model 3
js <- fromJSON('{"start": {"p1": 1,"p2": 0.1,"p3": 0.1,"p4": 1}, "lower": {"p1": -100,"p2": 0,"p3": 0,"p4": 0}, "upper": {"p1": 100,"p2": 100,"p3": 1,"p4": 2}}')
win_less <- 4
qmle_step <- 2
est <- yuima.qmle.seq(data = log(data), window = (length(data) - win_less), step = qmle_step, delta = delta, drift = "p1 * (p2 - x)", diffusion = "p3 * x^p4", hurst = 0.5, solve.variable = "x", method="L-BFGS-B",  start = js$start, lower = js$lower, upper = js$upper)
## . Simulate
coef_i <- win_less/qmle_step + 1
xinit <- data[length(data)]
return(exp(eulerOne(xinit = log(xinit), Terminal = T, nsim = nsim, parameter = list(p1 =est$coef$p1[coef_i], p2 = est$coef$p2[coef_i], p3 = est$coef$p3[coef_i], p4 = est$coef$p4[coef_i]))))
}
dd <- getData(request = list(class = "FX", base_currency = "DKK", currency = "GBP", frequency = "day", limit = 100))
simulate.all(dd)
sims <- simulate.all(dd)
hist(sims)
mean(sims)
sd(sims)
median(sims)
dd[length(dd)]
sims <- simulate.all(dd, T = 1/52, nsim = 150, delta = 1/365)
hist(sims)
mean(sims)
median(sims)
dd[length(dd)]
sd(sims)
paste("one", "two", "three")
paste("one", "two", "three", sep="")
aiUpdown <- function() {
#  data <- jsonlite::fromJSON(ai_request)
#  txt <- "The chance of profit is 10 percent, and the risk of loss is 12 percent of your activity amount."
#  txt <- paste(txt , data$result$parameters)
## . Check if results are already calculated and stored, else make new simulations; check if result and all parameters are there and correct;
## . Get market data
# tip: preload httr in opencpu
# tip: add date to fields to see actual data time stamps, and add verbose() to the POST parameters for more info on the call
# todo: filter weekend data out; check if a result is returned; test with lasso if model 3 is appropriate or perhaps a simpler model can be used e.g. where p4=1 <=> Brennan 92
xdata <- getData(request = list(class = "FX", base_currency = "USD", currency = "EUR", frequency = "day", limit = 252))
## . Estimate parameters
sims <- simulate.all(xdata, T = 1/52, nsim = 1000, delta = 1/365)
## Make wanted statistics
sims <- sort(sims)
q <- 0.01
up <- (sims[round((1-q) * nsim)] - xinit)/xinit  # q * 100 percent chance of up = up, or more up
down <- (sims[round(q * nsim)] - xinit)/xinit    # q * 100 percent chance of down = down, or further down
## Save results to db for next user
## Return forecast info to api.ai
txt <- jsonlite::unbox(paste("The chance of profit is", toString(up * 100), "percent, and the risk of loss is", toString(down * 100), " percent of your activity amount."))
return(list(speech = txt, displayText = txt, source = jsonlite::unbox("riskbutler.net")))
}
aiUpdown()
aiUpdown <- function() {
#  data <- jsonlite::fromJSON(ai_request)
#  txt <- "The chance of profit is 10 percent, and the risk of loss is 12 percent of your activity amount."
#  txt <- paste(txt , data$result$parameters)
## . Check if results are already calculated and stored, else make new simulations; check if result and all parameters are there and correct;
## . Get market data
# tip: preload httr in opencpu
# tip: add date to fields to see actual data time stamps, and add verbose() to the POST parameters for more info on the call
# todo: filter weekend data out; check if a result is returned; test with lasso if model 3 is appropriate or perhaps a simpler model can be used e.g. where p4=1 <=> Brennan 92
xdata <- getData(request = list(class = "FX", base_currency = "USD", currency = "EUR", frequency = "day", limit = 252))
## . Estimate parameters
nsim <- 1000
sims <- simulate.all(xdata, T = 1/52, nsim = nsim, delta = 1/365)
xinit <- xdata[length(xdata)]
## Make wanted statistics
sims <- sort(sims)
q <- 0.01
up <- (sims[round((1-q) * nsim)] - xinit)/xinit  # q * 100 percent chance of up = up, or more up
down <- (sims[round(q * nsim)] - xinit)/xinit    # q * 100 percent chance of down = down, or further down
## Save results to db for next user
## Return forecast info to api.ai
txt <- jsonlite::unbox(paste("The chance of profit is", toString(up * 100), "percent, and the risk of loss is", toString(down * 100), " percent of your activity amount."))
return(list(speech = txt, displayText = txt, source = jsonlite::unbox("riskbutler.net")))
}
aiUpdown()
?format
format(1:10, trim = TRUE)
format(1:10)
format(1:10, digits = 2)
format(0.03459287573838, digits = 2)
format(0.00003459287573838, digits = 2)
typeof(format(0.00003459287573838, digits = 2))
paste("The chance of profit is", format(0.098 * 100, digits = 2), "percent, and the risk of loss is", toString(0.0345 * 100), " percent of your activity amount.")
aiUpdown <- function() {
#  data <- jsonlite::fromJSON(ai_request)
#  txt <- "The chance of profit is 10 percent, and the risk of loss is 12 percent of your activity amount."
#  txt <- paste(txt , data$result$parameters)
## . Check if results are already calculated and stored, else make new simulations; check if result and all parameters are there and correct;
## . Get market data
# tip: preload httr in opencpu
# tip: add date to fields to see actual data time stamps, and add verbose() to the POST parameters for more info on the call
# todo: filter weekend data out; check if a result is returned; test with lasso if model 3 is appropriate or perhaps a simpler model can be used e.g. where p4=1 <=> Brennan 92
xdata <- getData(request = list(class = "FX", base_currency = "USD", currency = "EUR", frequency = "day", limit = 252))
## . Estimate parameters
nsim <- 1000
sims <- simulate.all(xdata, T = 1/52, nsim = nsim, delta = 1/365)
xinit <- xdata[length(xdata)]
## Make wanted statistics
sims <- sort(sims)
q <- 0.01
up <- (sims[round((1-q) * nsim)] - xinit)/xinit  # q * 100 percent chance of up = up, or more up
down <- (sims[round(q * nsim)] - xinit)/xinit    # q * 100 percent chance of down = down, or further down
## Save results to db for next user
## Return forecast info to api.ai
txt <- jsonlite::unbox(paste("The chance of profit is", format(up * 100, digits = 2), "percent, and the risk of loss is", format(down * 100, digits = 2), " percent of your activity amount. To understand how this was calculated please go to riskbutler.com."))
return(list(speech = txt, displayText = txt, source = jsonlite::unbox("riskbutler.net")))
}
aiUpdown()
ptm <- proc.time()
aiUpdown()
proc.time() - ptm
ptm <- proc.time()
aiUpdown()
proc.time() - ptm
json_obj = '{result: {parameters: {"activity_financial": "import", "amount-currency": {"amount": 100, "currency": "GBP"}, "base-currency": "DKK", "date": "2017-12-10"}}}'
api <- jsonlite::fromJSON(json)
api <- jsonlite::fromJSON(json_obj)
json_obj = '{"result": {"parameters": {"activity_financial": "import", "amount-currency": {"amount": 100, "currency": "GBP"}, "base-currency": "DKK", "date": "2017-12-10"}}}'
api <- jsonlite::fromJSON(json_obj)
api <- api$result$parameters
api
api$base_currency
json_obj = '{result: {parameters: {activity_financial: "import", amount-currency: {amount: 100, currency: "GBP"}, base-currency: "DKK", date: "2017-12-10"}}}'
api <- jsonlite::fromJSON(json_obj)
json_obj = '{"result": {"parameters": {"activity_financial": "import", "amount-currency": {"amount": 100, "currency": "GBP"}, "base-currency": "DKK", "date": "2017-12-10"}}}'
json_obj
api <- jsonlite::fromJSON(json_obj, flatten = TRUE)
api
fromJSON('{"result": {"parameters": {"activity_financial": "import", "amount-currency": {"amount": 100, "currency": "GBP"}, "base-currency": "DKK", "date": "2017-12-10"}}}', flatten = TRUE)
fromJSON('{"result": {"parameters": {"activity_financial": "import", amount-currency: {"amount": 100, "currency": "GBP"}, "base-currency": "DKK", "date": "2017-12-10"}}}', flatten = TRUE)
fromJSON('{"result": {"parameters": {"activity_financial": "import", "amount-currency": {"amount": 100, "currency": "GBP"}, "base-currency": "DKK", "date": "2017-12-10"}}}', flatten = FALSE)
json_obj = '{"result": {"parameters": {"activity_financial": "import", "amount_currency": {"amount": 100, "currency": "GBP"}, "base_currency": "DKK", "date": "2017-12-10"}}}'
api <- jsonlite::fromJSON(json_obj, flatten = TRUE)
api
api <- api$result$parameters
api
api$base_currency
api$amount_currency
api$amount_currency$currency
aiUpdown <- function(json_obj = '{"result": {"parameters": {"activity_financial": "import", "amount_currency": {"amount": 100, "currency": "GBP"}, "base_currency": "DKK", "date": "2017-12-10"}}}') {
api <- jsonlite::fromJSON(json_obj, flatten = TRUE)
api <- api$result$parameters
## . Check if results are already calculated and stored, else make new simulations; check if result and all parameters are there and correct;
## . Get market data
# tip: preload httr in opencpu
# tip: add date to fields to see actual data time stamps, and add verbose() to the POST parameters for more info on the call
# todo: filter weekend data out; check if a result is returned; test with lasso if model 3 is appropriate or perhaps a simpler model can be used e.g. where p4=1 <=> Brennan 92
xdata <- getData(request = list(class = "FX", base_currency = api$base_currency, currency = api$amount_currency$currency, frequency = "day", limit = 252))
## . Estimate parameters
nsim <- 1000
sims <- simulate.all(xdata, T = 1/52, nsim = nsim, delta = 1/365)
xinit <- xdata[length(xdata)]
## Make wanted statistics
sims <- sort(sims)
q <- 0.01
up <- (sims[round((1-q) * nsim)] - xinit)/xinit  # q * 100 percent chance of up = up, or more up
down <- (sims[round(q * nsim)] - xinit)/xinit    # q * 100 percent chance of down = down, or further down
## Save results to db for next user
## Return forecast info to api.ai
txt <- jsonlite::unbox(paste("The chance of profit is", format(up * 100, digits = 2), "percent, and the risk of loss is", format(down * 100, digits = 2), " percent of your", api$activity_financial, "activity amount. To understand how this was calculated please go to riskbutler.com."))
return(list(speech = txt, displayText = txt, source = jsonlite::unbox("riskbutler.net")))
}
aiUpdown()
api
ptm <- proc.time()
aiUpdown()
proc.time() - ptm
aiUpdown <- function(json_obj = '{"result": {"parameters": {"activity_financial": "import", "amount-currency": {"amount": 100, "currency": "GBP"}, "base-currency": "DKK", "date": "2017-12-10"}}}') {
api <- jsonlite::fromJSON(json_obj, flatten = TRUE)
api <- api$result$parameters
# temporary
base_currency <- api$`base-currency`
currency <- api$`amount-currency`$currency
## . Check if results are already calculated and stored, else make new simulations; check if result and all parameters are there and correct;
## . Get market data
# tip: preload httr in opencpu
# tip: add date to fields to see actual data time stamps, and add verbose() to the POST parameters for more info on the call
# todo: filter weekend data out; check if a result is returned; test with lasso if model 3 is appropriate or perhaps a simpler model can be used e.g. where p4=1 <=> Brennan 92
xdata <- getData(request = list(class = "FX", base_currency = base_currency, currency = currency, frequency = "day", limit = 252))
## . Estimate parameters
nsim <- 1000
sims <- simulate.all(xdata, T = 1/52, nsim = nsim, delta = 1/365)
xinit <- xdata[length(xdata)]
## Make wanted statistics
sims <- sort(sims)
q <- 0.01
up <- (sims[round((1-q) * nsim)] - xinit)/xinit  # q * 100 percent chance of up = up, or more up
down <- (sims[round(q * nsim)] - xinit)/xinit    # q * 100 percent chance of down = down, or further down
## Save results to db for next user
## Return forecast info to api.ai
txt <- jsonlite::unbox(paste("The chance of profit is", format(up * 100, digits = 2), "percent, and the risk of loss is", format(down * 100, digits = 2), " percent of your", api$activity_financial, "activity amount. To understand how this was calculated please go to riskbutler.com."))
return(list(speech = txt, displayText = txt, source = jsonlite::unbox("riskbutler.net")))
}
ptm <- proc.time()
aiUpdown()
proc.time() - ptm
library(riskbutlerRadar)
library(riskbutlerRadar)
library(riskbutlerRadar)
library(riskbutlerRadar)
aiUpdown()
library(riskbutlerRadar)
library(jsonlite)
library(httr)
aiUpdown()
library(riskbutlerRadar)
library(riskbutlerRadar)
library(riskbutlerRadar)
library(riskbutlerRadar)
library(riskbutlerRadar)
library(riskbutlerRadar)
library(riskbutlerRadar)
library(riskbutlerRadar)
library(riskbutlerRadar)
library(devtools)
?install_github
?install.packages
getOption("repos")
library(riskbutlerRadar)
aiUpdown()
dd <- getData(request = list(class = "FX", base_currency = "DKK", currency = "GBP", frequency = "day", limit = 100))
sims <- simulate_all(dd)
hist(sims)
mean(sims)
dd
sd(dd)
sd(sims)
?is.na
fromJSON('{"result": {"parameters": {"activity_financial": "import", "amount_currency": {"amount": 100, "currency": "GBP"}, "base_currency": "DKK", "date": "2017-12-10"}}}')
library(jsonlite)
fromJSON('{"result": {"parameters": {"activity_financial": "import", "amount_currency": {"amount": 100, "currency": "GBP"}, "base_currency": "DKK", "date": "2017-12-10"}}}')
fromJSON(' {"parameters": {"activity_financial": "import", "amount_currency": {"amount": 100, "currency": "GBP"}, "base_currency": "DKK", "date": "2017-12-10"}}')
result <- fromJSON('{"parameters": {"activity_financial": "import", "amount_currency": {"amount": 100, "currency": "GBP"}, "base_currency": "DKK", "date": "2017-12-10"}}')
result
api <- result$parameters
api
base_currency <- api$base_currency
currency <- api$amount_currency$currency
aiUpdown <- function(result, ...) {
if (missing(result)) {
result <- fromJSON('{"parameters": {"activity_financial": "import", "amount_currency": {"amount": 100, "currency": "GBP"}, "base_currency": "DKK", "date": "2017-12-10"}}')
}
api <- result$parameters
# temporary
base_currency <- api$base_currency
currency <- api$amount_currency$currency
## . Check if results are already calculated and stored, else make new simulations; check if result and all parameters are there and correct;
## . Get market data
# tip: preload httr in opencpu
# tip: add date to fields to see actual data time stamps, and add verbose() to the POST parameters for more info on the call
# todo: filter weekend data out; check if a result is returned; test with lasso if model 3 is appropriate or perhaps a simpler model can be used e.g. where p4=1 <=> Brennan 92
xdata <- riskbutlerRadar::getData(request = list(class = "FX", base_currency = base_currency, currency = currency, frequency = "day", limit = 252))
## . Estimate parameters
nsim <- 1000
sims <- riskbutlerRadar::simulate_all(xdata, T = 1/52, nsim = nsim, delta = 1/365)
xinit <- xdata[length(xdata)]
## Make wanted statistics
sims <- sort(sims)
q <- 0.01
up <- (sims[round((1-q) * nsim)] - xinit)/xinit  # q * 100 percent chance of up = up, or more up
down <- (sims[round(q * nsim)] - xinit)/xinit    # q * 100 percent chance of down = down, or further down
## Save results to db for next user
## Return forecast info to api.ai
txt <- jsonlite::unbox(paste("The chance of profit is", format(up * 100, digits = 2), "percent, and the risk of loss is", format(down * 100, digits = 2), " percent of your", api$activity_financial, "activity amount. To understand how this was calculated please go to riskbutler.com."))
return(list(speech = txt, displayText = txt, source = jsonlite::unbox("riskbutler.net")))
}
aiUpdown()
aiUpdown(id = "8c71919d-ebb6-467e-866f-0e05509afdde", timestamp = "2017-06-15T13:33:17.691Z", lang = "en", status = status, sessionId = "somerandomthing")
library(riskbutlerRadar)
library(riskbutlerRadar)
library(riskbutlerRadar)
library(riskbutlerRadar)
