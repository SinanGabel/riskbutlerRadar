l <- seq(1, n - w + s, s)
if ((l[length(l)] + w - 1) > n ) {
l[length(l)] = n - w + 1
}
return(l)
}
l <- sekvens(datalength, 100, 10)
# --- multivariate estimations for dX = θ1·(θ2 - X)·dt + θ3·dW, Ornstein-Uhlenbeck (OU) 1 ---
# log is taken in function
funcor <- function(data, start) {
rho <- cor(data)[2,1]
#rho <- 0.75
sol <- c("x1", "x2")
b <- c("p1.1 * (p2.1 - x1)", "p1.2 * (p2.2 - x2)")
e21 <- gsub("rho", rho, "(p3.2 * x2) * rho")
e22 <- gsub("rho", rho, "(p3.2 * x2) * sqrt(1 - (rho)^2)")
s <- matrix(c("p3.1 * x1", e21, 0, e22), 2, 2)
js <- jsonlite::fromJSON('{"start": {"p1.1": 1,"p2.1": 0.1,"p3.1": 0.1, "p1.2": 1,"p2.2": 0.1,"p3.2": 0.1}, "lower": {"p1.1": -100,"p2.1": 0,"p3.1": 0, "p1.2": -100,"p2.2": 0,"p3.2": 0}, "upper": {"p1.1": 100,"p2.1": 100,"p3.1": 100, "p1.2": 100,"p2.2": 100,"p3.2": 100}}')
if (missing(start)) {
start = js$start
}
est <- riskbutlerRadar::yuima.qmle(log(data), delta = 1/365, drift = b, diffusion = s, solve.variable = sol, method="L-BFGS-B", start = start, lower = js$lower, upper = js$upper, summary = FALSE)
return(est)
}
# -- multivariate simulations
# supply data without first taking log()
funsim <- function(data) {
w <- 100
step <- 5
l <- sekvens(length(data[,1]), w, step)
#ll <- length(l)
# init (log) estimation
est <- funcor(data[seq(1, 1+w-1),])
est <- as.list(est@coef)
r <- foreach::foreach(i = l, .combine = rbind) %do% {
dat <- data[seq(i, i+w-1),]
est <- funcor(dat, est)
# To use estimates as start values in next or other qmle estimation set: start = as.list(res@coef)
est <- as.list(est@coef)
# ---
rho <- cor(dat)[2,1]
#rho <- 0.75
sol <- c("x1", "x2")
b <- c("p1.1 * (p2.1 - x1)", "p1.2 * (p2.2 - x2)")
e21 <- gsub("rho", rho, "(p3.2 * x2) * rho")
e22 <- gsub("rho", rho, "(p3.2 * x2) * sqrt(1 - (rho)^2)")
s <- matrix(c("p3.1 * x1", e21, 0, e22), 2, 2)
# risk time forecast approx. 7 days or 1 calendar week
sim <- riskbutlerRadar::yuima.simulate(setseed = FALSE, sumsim = FALSE, nsim = 2000, drift = b, diffusion = s, xinit = log(dat[w,]), solve.variable = sol, Terminal = 1/52, n= 1, parameter = est)
sim <- exp(sim)
}
return(r)
}
multisims <- funsim(xdata)
colnames(multisims) <- c("CHF","SEK")
write.csv(as.table(multisims), "./multisims.csv", row.names=FALSE)
View(xdata)
write.csv(as.table(xdata), "./marketdata_daily_base_DKK.csv", row.names=FALSE)
write.csv(xdata, "./marketdata_daily_base_DKK.csv", row.names=FALSE)
funcor <- function(data, start) {
#rho <- cor(data)[2,1]
rho <- 0
sol <- c("x1", "x2")
b <- c("p1.1 * (p2.1 - x1)", "p1.2 * (p2.2 - x2)")
e21 <- gsub("rho", rho, "(p3.2 * x2) * rho")
e22 <- gsub("rho", rho, "(p3.2 * x2) * sqrt(1 - (rho)^2)")
s <- matrix(c("p3.1 * x1", e21, 0, e22), 2, 2)
js <- jsonlite::fromJSON('{"start": {"p1.1": 1,"p2.1": 0.1,"p3.1": 0.1, "p1.2": 1,"p2.2": 0.1,"p3.2": 0.1}, "lower": {"p1.1": -100,"p2.1": 0,"p3.1": 0, "p1.2": -100,"p2.2": 0,"p3.2": 0}, "upper": {"p1.1": 100,"p2.1": 100,"p3.1": 100, "p1.2": 100,"p2.2": 100,"p3.2": 100}}')
if (missing(start)) {
start = js$start
}
est <- riskbutlerRadar::yuima.qmle(log(data), delta = 1/365, drift = b, diffusion = s, solve.variable = sol, method="L-BFGS-B", start = start, lower = js$lower, upper = js$upper, summary = FALSE)
return(est)
}
funsim <- function(data) {
w <- 100
step <- 5
l <- sekvens(length(data[,1]), w, step)
#ll <- length(l)
# init (log) estimation
est <- funcor(data[seq(1, 1+w-1),])
est <- as.list(est@coef)
r <- foreach::foreach(i = l, .combine = rbind) %do% {
dat <- data[seq(i, i+w-1),]
est <- funcor(dat, est)
# To use estimates as start values in next or other qmle estimation set: start = as.list(res@coef)
est <- as.list(est@coef)
# ---
#rho <- cor(dat)[2,1]
rho <- 0
sol <- c("x1", "x2")
b <- c("p1.1 * (p2.1 - x1)", "p1.2 * (p2.2 - x2)")
e21 <- gsub("rho", rho, "(p3.2 * x2) * rho")
e22 <- gsub("rho", rho, "(p3.2 * x2) * sqrt(1 - (rho)^2)")
s <- matrix(c("p3.1 * x1", e21, 0, e22), 2, 2)
# risk time forecast approx. 7 days or 1 calendar week
sim <- riskbutlerRadar::yuima.simulate(setseed = FALSE, sumsim = FALSE, nsim = 2000, drift = b, diffusion = s, xinit = log(dat[w,]), solve.variable = sol, Terminal = 1/52, n= 1, parameter = est)
sim <- exp(sim)
}
return(r)
}
unisims <- funsim(xdata)
colnames(unisims) <- c("CHF","SEK")
write.csv(as.table(unisims), "./unisims.csv", row.names=FALSE)
sekvens(300, 100, 5)
funparam <- function(data, model = "you3", correlated = FALSE) {
rho <- 0
if (correlated == TRUE) {
rho <- cor(data)[2,1]
}
if (model == "you3") {
b <- c("p1.1 * (p2.1 - x1)", "p1.2 * (p2.2 - x2)")
e21 <- gsub("rho", rho, "(p3.2 * x2) * rho")
e22 <- gsub("rho", rho, "(p3.2 * x2) * sqrt(1 - (rho)^2)")
s <- matrix(c("p3.1 * x1", e21, 0, e22), 2, 2)
slu <- jsonlite::fromJSON('{"start": {"p1.1": 1,"p2.1": 0.1,"p3.1": 0.1, "p1.2": 1,"p2.2": 0.1,"p3.2": 0.1}, "lower": {"p1.1": -100,"p2.1": 0,"p3.1": 0, "p1.2": -100,"p2.2": 0,"p3.2": 0}, "upper": {"p1.1": 100,"p2.1": 100,"p3.1": 100, "p1.2": 100,"p2.2": 100,"p3.2": 100}}')
sol <- c("x1", "x2")
} else if (model == "") {
}
return(list(drift = b, diffusion = s, solve.variable = sol, slu = slu))
}
funparam(xdata, model = "you3", correlated = FALSE)
dd <- funparam(xdata, model = "you3", correlated = FALSE)
dd$slu$start
dd$drift
library(jsonlite)
library(yuima)
library(riskbutlerRadar)
library(foreach)
# - korreleret tidsserier
datalength <- 300
chf <- getData(request = list(class = "FX", base_currency = "DKK", currency = "CHF", frequency = "day", limit = datalength))
sek <- getData(request = list(class = "FX", base_currency = "DKK", currency = "SEK", frequency = "day", limit = datalength))
xdata <- data.frame(chf, sek)
cor(xdata)
plot(xdata)
# --
sekvens <- function(n, w, s) {
l <- seq(1, n - w + s, s)
if ((l[length(l)] + w - 1) > n ) {
l[length(l)] = n - w + 1
}
return(l)
}
l <- sekvens(datalength, 100, 10)
funparam <- function(data, model = "you3", correlated = FALSE) {
rho <- 0
if (correlated == TRUE) {
rho <- cor(data)[2,1]
}
if (model == "you3") { # dX = θ1·(θ2 - X)·dt + θ3·X·dW, Brennan & Schwartz 1980
b <- c("p1.1 * (p2.1 - x1)", "p1.2 * (p2.2 - x2)")
e21 <- gsub("rho", rho, "(p3.2 * x2) * rho")
e22 <- gsub("rho", rho, "(p3.2 * x2) * sqrt(1 - (rho)^2)")
s <- matrix(c("p3.1 * x1", e21, 0, e22), 2, 2)
slu <- jsonlite::fromJSON('{"start": {"p1.1": 1,"p2.1": 0.1,"p3.1": 0.1, "p1.2": 1,"p2.2": 0.1,"p3.2": 0.1}, "lower": {"p1.1": -100,"p2.1": 0,"p3.1": 0, "p1.2": -100,"p2.2": 0,"p3.2": 0}, "upper": {"p1.1": 100,"p2.1": 100,"p3.1": 100, "p1.2": 100,"p2.2": 100,"p3.2": 100}}')
sol <- c("x1", "x2")
} else if (model == "yckls") {  # dX = θ1·(θ2 - X)·dt + θ3·X^θ4·dW, Chan-Karolyi-Longstaff-Sanders 1992
b <- c("p1.1 * (p2.1 - x1)", "p1.2 * (p2.2 - x2)")
e21 <- gsub("rho", rho, "(p3.2 * x2^p4.2) * rho")
e22 <- gsub("rho", rho, "(p3.2 * x2^p4.2) * sqrt(1 - (rho)^2)")
s <- matrix(c("p3.1 * x1^p4.1", e21, 0, e22), 2, 2)
slu <- jsonlite::fromJSON('{"start": {"p1.1": 1,"p2.1": 0.1,"p3.1": 0.1, "p4.1": 1, "p1.2": 1,"p2.2": 0.1,"p3.2": 0.1, "p4.2": 1}, "lower": {"p1.1": -100,"p2.1": 0,"p3.1": 0, "p4.1": 0, "p1.2": -100,"p2.2": 0,"p3.2": 0, "p4.2": 0}, "upper": {"p1.1": 100,"p2.1": 100,"p3.1": 100, "p4.1": 2, "p1.2": 100,"p2.2": 100,"p3.2": 100, "p4.1": 2}}')
sol <- c("x1", "x2")
} else if (model == "yhdf") {  # dX = sigma^2/2·(beta - gamma·X/Sqrt(delta^2 + (X - mu)^2)·dt + sigma·dW, Hyperbolic diffusion (dynamics of sand - the sand project, AAU); Iacus, 2011, Chicago R/Finance, April 29
b <- c("(p1.1^2)/2 * (p2.1 - p3.1 * x /sqrt(p4.1^2 + (x - p5.1)^2))", "(p1.2^2)/2 * (p2.2 - p3.2 * x /sqrt(p4.2^2 + (x - p5.2)^2))")
e21 <- gsub("rho", rho, "p1.2 * rho")
e22 <- gsub("rho", rho, "p1.2 * sqrt(1 - (rho)^2)")
s <- matrix(c("p1.1", e21, 0, e22), 2, 2)
slu <- jsonlite::fromJSON('{"start": {"p1.1": 0.1,"p2.1": 0.1,"p3.1": 0.1, "p4.1": 0.1, "p5.1": 0.1, "p1.2": 0.1,"p2.2": 0.1,"p3.2": 0.1, "p4.2": 0.1, "p5.1": 0.1}, "lower": {"p1.1": 0,"p2.1": -100,"p3.1": -1, "p4.1": 0, "p5.1": -100, "p1.2": 0,"p2.2": -100,"p3.2": -1, "p4.2": 0, "p5.1": -100}, "upper": {"p1.1": 1,"p2.1": 100,"p3.1": 1, "p4.1": 1, "p5.1": 100, "p1.2": 1,"p2.2": 100,"p3.2": 1, "p4.1": 1, "p5.1": 100}}')
sol <- c("x1", "x2")
}
return(list(drift = b, diffusion = s, solve.variable = sol, slu = slu))
}
funparam(xdata, model = "you3", correlated = FALSE)
funparam(xdata, model = "you3", correlated = TRUE)
funparam(xdata, model = "yckls", correlated = FALSE)
funparam(xdata, model = "yckls", correlated = TRUE)
funparam(xdata, model = "yhdf", correlated = FALSE)
funparam(xdata, model = "yhdf", correlated = TRUE)
funcor <- function(data, start, model = "you3", correlated = FALSE) {
p <- funparam(data, model, correlated)
if (missing(start)) {
start = p$slu$start
}
est <- riskbutlerRadar::yuima.qmle(log(data), delta = 1/365, drift = p$drift, diffusion = p$diffusion, solve.variable = p$solve.variable, method="L-BFGS-B", start = start, lower = p$slu$lower, upper = p$slu$upper, summary = FALSE)
return(est)
}
funsim <- function(data, model = "you3", correlated = FALSE) {
w <- 100
step <- 5
l <- sekvens(length(data[,1]), w, step)
# init (log) estimation
est <- funcor(data[seq(1, 1+w-1),], model, correlated)
est <- as.list(est@coef)
r <- foreach::foreach(i = l, .combine = rbind) %do% {
dat <- data[seq(i, i+w-1),]
est <- funcor(dat, est, model, correlated)
# To use estimates as start values in next or other qmle estimation set: start = as.list(res@coef)
est <- as.list(est@coef)
# ---
p <- funparam(data, model, correlated)
# risk time forecast approx. 7 days or 1 calendar week
sim <- riskbutlerRadar::yuima.simulate(setseed = FALSE, sumsim = FALSE, nsim = 2000, drift = p$drift, diffusion = p$diffusion, solve.variable = p$solve.variable, xinit = log(dat[w,]), Terminal = 1/52, n= 1, parameter = est)
sim <- exp(sim)
}
return(r)
}
sims <- funsim(xdata, model = "yckls", correlated = FALSE)
colnames(sims) <- c("CHF","SEK")
write.csv(as.table(sims), "./unisims-chan92.csv", row.names=FALSE)
missing(NULL)
missing(NULL) == TRUE
funcor <- function(data, model = "you3", correlated = FALSE, start) {
p <- funparam(data, model, correlated)
if (missing(start)) {
start = p$slu$start
}
est <- riskbutlerRadar::yuima.qmle(log(data), delta = 1/365, drift = p$drift, diffusion = p$diffusion, solve.variable = p$solve.variable, method="L-BFGS-B", start = start, lower = p$slu$lower, upper = p$slu$upper, summary = FALSE)
return(est)
}
# -- multivariate simulations
# supply data without first taking log()
funsim <- function(data, model = "you3", correlated = FALSE) {
w <- 100
step <- 5
l <- sekvens(length(data[,1]), w, step)
# init (log) estimation
est <- funcor(data[seq(1, 1+w-1),], model, correlated)
est <- as.list(est@coef)
r <- foreach::foreach(i = l, .combine = rbind) %do% {
dat <- data[seq(i, i+w-1),]
est <- funcor(dat, model, correlated, est)
# To use estimates as start values in next or other qmle estimation set: start = as.list(res@coef)
est <- as.list(est@coef)
# ---
p <- funparam(data, model, correlated)
# risk time forecast approx. 7 days or 1 calendar week
sim <- riskbutlerRadar::yuima.simulate(setseed = FALSE, sumsim = FALSE, nsim = 2000, drift = p$drift, diffusion = p$diffusion, solve.variable = p$solve.variable, xinit = log(dat[w,]), Terminal = 1/52, n= 1, parameter = est)
sim <- exp(sim)
}
return(r)
}
sims <- funsim(xdata, model = "yckls", correlated = FALSE)
colnames(sims) <- c("CHF","SEK")
write.csv(as.table(sims), "./unisims-chan92.csv", row.names=FALSE)
sims <- funsim(xdata, model = "yckls", correlated = TRUE)
colnames(sims) <- c("CHF","SEK")
write.csv(as.table(sims), "./multisims-chan92.csv", row.names=FALSE)
sims <- funsim(xdata, model = "yhdf", correlated = FALSE)
colnames(sims) <- c("CHF","SEK")
write.csv(as.table(sims), "./unisims-hyperbolic.csv", row.names=FALSE)
sims <- funsim(xdata, model = "yckls", correlated = TRUE)
library(jsonlite)
library(yuima)
library(riskbutlerRadar)
library(foreach)
# - korreleret tidsserier
datalength <- 300
chf <- getData(request = list(class = "FX", base_currency = "DKK", currency = "CHF", frequency = "day", limit = datalength))
sek <- getData(request = list(class = "FX", base_currency = "DKK", currency = "SEK", frequency = "day", limit = datalength))
xdata <- data.frame(chf, sek)
write.csv(xdata, "./marketdata_daily_base_DKK.csv", row.names=FALSE)
cor(xdata)
plot(xdata)
# --
sekvens <- function(n, w, s) {
l <- seq(1, n - w + s, s)
if ((l[length(l)] + w - 1) > n ) {
l[length(l)] = n - w + 1
}
return(l)
}
l <- sekvens(datalength, 100, 10)
funparam <- function(data, model = "you3", correlated = FALSE) {
rho <- 0
if (correlated == TRUE) {
rho <- cor(data)[2,1]
}
# dX = θ1·(θ2 - X)·dt + θ3·X·dW, Brennan & Schwartz 1980
if (model == "you3") {
b <- c("p1.1 * (p2.1 - x1)", "p1.2 * (p2.2 - x2)")
e21 <- gsub("rho", rho, "(p3.2 * x2) * rho")
e22 <- gsub("rho", rho, "(p3.2 * x2) * sqrt(1 - (rho)^2)")
s <- matrix(c("p3.1 * x1", e21, 0, e22), 2, 2)
slu <- jsonlite::fromJSON('{"start": {"p1.1": 1,"p2.1": 0.1,"p3.1": 0.1, "p1.2": 1,"p2.2": 0.1,"p3.2": 0.1}, "lower": {"p1.1": -100,"p2.1": 0,"p3.1": 0, "p1.2": -100,"p2.2": 0,"p3.2": 0}, "upper": {"p1.1": 100,"p2.1": 100,"p3.1": 100, "p1.2": 100,"p2.2": 100,"p3.2": 100}}')
sol <- c("x1", "x2")
# dX = θ1·(θ2 - X)·dt + θ3·X^θ4·dW, Chan-Karolyi-Longstaff-Sanders 1992
} else if (model == "yckls") {
b <- c("p1.1 * (p2.1 - x1)", "p1.2 * (p2.2 - x2)")
e21 <- gsub("rho", rho, "(p3.2 * x2^p4.2) * rho")
e22 <- gsub("rho", rho, "(p3.2 * x2^p4.2) * sqrt(1 - (rho)^2)")
s <- matrix(c("p3.1 * x1^p4.1", e21, 0, e22), 2, 2)
slu <- jsonlite::fromJSON('{"start": {"p1.1": 1,"p2.1": 0.1,"p3.1": 0.1, "p4.1": 1, "p1.2": 1,"p2.2": 0.1,"p3.2": 0.1, "p4.2": 1}, "lower": {"p1.1": -100,"p2.1": 0,"p3.1": 0, "p4.1": 0, "p1.2": -100,"p2.2": 0,"p3.2": 0, "p4.2": 0}, "upper": {"p1.1": 100,"p2.1": 100,"p3.1": 100, "p4.1": 2, "p1.2": 100,"p2.2": 100,"p3.2": 100, "p4.1": 2}}')
sol <- c("x1", "x2")
# dX = sigma^2/2·(beta - gamma·X/Sqrt(delta^2 + (X - mu)^2)·dt + sigma·dW, Hyperbolic diffusion (dynamics of sand - the sand project, AAU); Iacus, 2011, Chicago R/Finance, April 29
} else if (model == "yhdf") {
b <- c("(p1.1^2)/2 * (p2.1 - p3.1 * x1 /sqrt(p4.1^2 + (x1 - p5.1)^2))", "(p1.2^2)/2 * (p2.2 - p3.2 * x2 /sqrt(p4.2^2 + (x2 - p5.2)^2))")
e21 <- gsub("rho", rho, "p1.2 * rho")
e22 <- gsub("rho", rho, "p1.2 * sqrt(1 - (rho)^2)")
s <- matrix(c("p1.1", e21, 0, e22), 2, 2)
slu <- jsonlite::fromJSON('{"start": {"p1.1": 0.1,"p2.1": 0.1,"p3.1": 0.1, "p4.1": 0.1, "p5.1": 0.1, "p1.2": 0.1,"p2.2": 0.1,"p3.2": 0.1, "p4.2": 0.1, "p5.1": 0.1}, "lower": {"p1.1": 0,"p2.1": -100,"p3.1": -1, "p4.1": 0, "p5.1": -100, "p1.2": 0,"p2.2": -100,"p3.2": -1, "p4.2": 0, "p5.1": -100}, "upper": {"p1.1": 1,"p2.1": 100,"p3.1": 1, "p4.1": 1, "p5.1": 100, "p1.2": 1,"p2.2": 100,"p3.2": 1, "p4.1": 1, "p5.1": 100}}')
sol <- c("x1", "x2")
}
return(list(drift = b, diffusion = s, solve.variable = sol, slu = slu))
}
funcor <- function(data, model = "you3", correlated = FALSE, start) {
p <- funparam(data, model, correlated)
if (missing(start)) {
start = p$slu$start
}
est <- riskbutlerRadar::yuima.qmle(log(data), delta = 1/365, drift = p$drift, diffusion = p$diffusion, solve.variable = p$solve.variable, method="L-BFGS-B", start = start, lower = p$slu$lower, upper = p$slu$upper, summary = FALSE)
return(est)
}
# -- multivariate simulations
# supply data without first taking log()
funsim <- function(data, model = "you3", correlated = FALSE) {
w <- 100
step <- 5
l <- sekvens(length(data[,1]), w, step)
# init (log) estimation
est <- funcor(data[seq(1, 1+w-1),], model, correlated)
est <- as.list(est@coef)
r <- foreach::foreach(i = l, .combine = rbind) %do% {
dat <- data[seq(i, i+w-1),]
est <- funcor(dat, model, correlated, est)
# To use estimates as start values in next or other qmle estimation set: start = as.list(res@coef)
est <- as.list(est@coef)
# ---
p <- funparam(data, model, correlated)
# risk time forecast approx. 7 days or 1 calendar week
sim <- riskbutlerRadar::yuima.simulate(setseed = FALSE, sumsim = FALSE, nsim = 2000, drift = p$drift, diffusion = p$diffusion, solve.variable = p$solve.variable, xinit = log(dat[w,]), Terminal = 1/52, n= 1, parameter = est)
sim <- exp(sim)
}
return(r)
}
sims <- funsim(xdata, model = "yckls", correlated = TRUE)
colnames(sims) <- c("CHF","SEK")
write.csv(as.table(sims), "./multisims-chan92.csv", row.names=FALSE)
sims <- funsim(xdata, model = "yhdf", correlated = FALSE)
colnames(sims) <- c("CHF","SEK")
write.csv(as.table(sims), "./unisims-hyperbolic.csv", row.names=FALSE)
funparam <- function(data, model = "you3", correlated = FALSE) {
rho <- 0
if (correlated == TRUE) {
rho <- cor(data)[2,1]
}
# dX = θ1·(θ2 - X)·dt + θ3·X·dW, Brennan & Schwartz 1980
if (model == "you3") {
b <- c("p1.1 * (p2.1 - x1)", "p1.2 * (p2.2 - x2)")
e21 <- gsub("rho", rho, "(p3.2 * x2) * rho")
e22 <- gsub("rho", rho, "(p3.2 * x2) * sqrt(1 - (rho)^2)")
s <- matrix(c("p3.1 * x1", e21, 0, e22), 2, 2)
slu <- jsonlite::fromJSON('{"start": {"p1.1": 1,"p2.1": 0.1,"p3.1": 0.1, "p1.2": 1,"p2.2": 0.1,"p3.2": 0.1}, "lower": {"p1.1": -100,"p2.1": 0,"p3.1": 0, "p1.2": -100,"p2.2": 0,"p3.2": 0}, "upper": {"p1.1": 100,"p2.1": 100,"p3.1": 100, "p1.2": 100,"p2.2": 100,"p3.2": 100}}')
sol <- c("x1", "x2")
# dX = θ1·(θ2 - X)·dt + θ3·X^θ4·dW, Chan-Karolyi-Longstaff-Sanders 1992
} else if (model == "yckls") {
b <- c("p1.1 * (p2.1 - x1)", "p1.2 * (p2.2 - x2)")
e21 <- gsub("rho", rho, "(p3.2 * x2^p4.2) * rho")
e22 <- gsub("rho", rho, "(p3.2 * x2^p4.2) * sqrt(1 - (rho)^2)")
s <- matrix(c("p3.1 * x1^p4.1", e21, 0, e22), 2, 2)
slu <- jsonlite::fromJSON('{"start": {"p1.1": 1,"p2.1": 0.1,"p3.1": 0.1, "p4.1": 1, "p1.2": 1,"p2.2": 0.1,"p3.2": 0.1, "p4.2": 1}, "lower": {"p1.1": -100,"p2.1": 0,"p3.1": 0, "p4.1": 0, "p1.2": -100,"p2.2": 0,"p3.2": 0, "p4.2": 0}, "upper": {"p1.1": 100,"p2.1": 100,"p3.1": 100, "p4.1": 2, "p1.2": 100,"p2.2": 100,"p3.2": 100, "p4.1": 2}}')
sol <- c("x1", "x2")
# dX = sigma^2/2·(beta - gamma·X/Sqrt(delta^2 + (X - mu)^2)·dt + sigma·dW, Hyperbolic diffusion (dynamics of sand - the sand project, AAU); Iacus, 2011, Chicago R/Finance, April 29
} else if (model == "yhdf") {
b <- c("(p1.1^2)/2 * (p2.1 - p3.1 * x1 /sqrt(p4.1^2 + (x1 - p5.1)^2))", "(p1.2^2)/2 * (p2.2 - p3.2 * x2 /sqrt(p4.2^2 + (x2 - p5.2)^2))")
e21 <- gsub("rho", rho, "p1.2 * rho")
e22 <- gsub("rho", rho, "p1.2 * sqrt(1 - (rho)^2)")
s <- matrix(c("p1.1", e21, 0, e22), 2, 2)
slu <- jsonlite::fromJSON('{"start": {"p1.1": 0.1,"p2.1": 0.1,"p3.1": 0.1, "p4.1": 0.1, "p5.1": 0.1, "p1.2": 0.1,"p2.2": 0.1,"p3.2": 0.1, "p4.2": 0.1, "p5.2": 0.1}, "lower": {"p1.1": 0,"p2.1": -100,"p3.1": -1, "p4.1": 0, "p5.1": -100, "p1.2": 0,"p2.2": -100,"p3.2": -1, "p4.2": 0, "p5.2": -100}, "upper": {"p1.1": 1,"p2.1": 100,"p3.1": 1, "p4.1": 1, "p5.1": 100, "p1.2": 1,"p2.2": 100,"p3.2": 1, "p4.1": 1, "p5.2": 100}}')
sol <- c("x1", "x2")
}
return(list(drift = b, diffusion = s, solve.variable = sol, slu = slu))
}
funparam <- function(data, model = "you3", correlated = FALSE) {
rho <- 0
if (correlated == TRUE) {
rho <- cor(data)[2,1]
}
# dX = θ1·(θ2 - X)·dt + θ3·X·dW, Brennan & Schwartz 1980
if (model == "you3") {
b <- c("p1.1 * (p2.1 - x1)", "p1.2 * (p2.2 - x2)")
e21 <- gsub("rho", rho, "(p3.2 * x2) * rho")
e22 <- gsub("rho", rho, "(p3.2 * x2) * sqrt(1 - (rho)^2)")
s <- matrix(c("p3.1 * x1", e21, 0, e22), 2, 2)
slu <- jsonlite::fromJSON('{"start": {"p1.1": 1,"p2.1": 0.1,"p3.1": 0.1, "p1.2": 1,"p2.2": 0.1,"p3.2": 0.1}, "lower": {"p1.1": -100,"p2.1": 0,"p3.1": 0, "p1.2": -100,"p2.2": 0,"p3.2": 0}, "upper": {"p1.1": 100,"p2.1": 100,"p3.1": 100, "p1.2": 100,"p2.2": 100,"p3.2": 100}}')
sol <- c("x1", "x2")
# dX = θ1·(θ2 - X)·dt + θ3·X^θ4·dW, Chan-Karolyi-Longstaff-Sanders 1992
} else if (model == "yckls") {
b <- c("p1.1 * (p2.1 - x1)", "p1.2 * (p2.2 - x2)")
e21 <- gsub("rho", rho, "(p3.2 * x2^p4.2) * rho")
e22 <- gsub("rho", rho, "(p3.2 * x2^p4.2) * sqrt(1 - (rho)^2)")
s <- matrix(c("p3.1 * x1^p4.1", e21, 0, e22), 2, 2)
slu <- jsonlite::fromJSON('{"start": {"p1.1": 1,"p2.1": 0.1,"p3.1": 0.1, "p4.1": 1, "p1.2": 1,"p2.2": 0.1,"p3.2": 0.1, "p4.2": 1}, "lower": {"p1.1": -100,"p2.1": 0,"p3.1": 0, "p4.1": 0, "p1.2": -100,"p2.2": 0,"p3.2": 0, "p4.2": 0}, "upper": {"p1.1": 100,"p2.1": 100,"p3.1": 100, "p4.1": 2, "p1.2": 100,"p2.2": 100,"p3.2": 100, "p4.1": 2}}')
sol <- c("x1", "x2")
# dX = sigma^2/2·(beta - gamma·X/Sqrt(delta^2 + (X - mu)^2)·dt + sigma·dW, Hyperbolic diffusion (dynamics of sand - the sand project, AAU); Iacus, 2011, Chicago R/Finance, April 29
} else if (model == "yhdf") {
b <- c("(p1.1^2)/2 * (p2.1 - p3.1 * x1 /sqrt(p4.1^2 + (x1 - p5.1)^2))", "(p1.2^2)/2 * (p2.2 - p3.2 * x2 /sqrt(p4.2^2 + (x2 - p5.2)^2))")
e21 <- gsub("rho", rho, "p1.2 * rho")
e22 <- gsub("rho", rho, "p1.2 * sqrt(1 - (rho)^2)")
s <- matrix(c("p1.1", e21, 0, e22), 2, 2)
slu <- jsonlite::fromJSON('{"start": {"p1.1": 0.1,"p2.1": 0.1,"p3.1": 0.1, "p4.1": 0.1, "p5.1": 0.1, "p1.2": 0.1,"p2.2": 0.1,"p3.2": 0.1, "p4.2": 0.1, "p5.2": 0.1}, "lower": {"p1.1": 0,"p2.1": -100,"p3.1": -1, "p4.1": 0, "p5.1": -100, "p1.2": 0,"p2.2": -100,"p3.2": -1, "p4.2": 0, "p5.2": -100}, "upper": {"p1.1": 1,"p2.1": 100,"p3.1": 1, "p4.1": 1, "p5.1": 100, "p1.2": 1,"p2.2": 100,"p3.2": 1, "p4.1": 1, "p5.2": 100}}')
sol <- c("x1", "x2")
}
return(list(drift = b, diffusion = s, solve.variable = sol, slu = slu))
}
sims <- funsim(xdata, model = "yhdf", correlated = FALSE)
colnames(sims) <- c("CHF","SEK")
write.csv(as.table(sims), "./unisims-hyperbolic.csv", row.names=FALSE)
sims2 <- funsim(xdata, model = "yhdf", correlated = TRUE)
colnames(sims2) <- c("CHF","SEK")
write.csv(as.table(sims2), "./multisims-hyperbolic.csv", row.names=FALSE)
# This is an implementation of a simulataneous estimation and simulation for two time series (can be expanded easily to n time series)
# Written by Sinan Gabel
# new ---
library(jsonlite)
library(yuima)
library(riskbutlerRadar)
library(foreach)
# - korreleret tidsserier
datalength <- 300
chf <- getData(request = list(class = "FX", base_currency = "DKK", currency = "CHF", frequency = "day", limit = datalength))
sek <- getData(request = list(class = "FX", base_currency = "DKK", currency = "SEK", frequency = "day", limit = datalength))
xdata <- data.frame(chf, sek)
write.csv(xdata, "./marketdata_daily_base_DKK.csv", row.names=FALSE)
cor(xdata)
plot(xdata)
# --
sekvens <- function(n, w, s) {
l <- seq(1, n - w + s, s)
if ((l[length(l)] + w - 1) > n ) {
l[length(l)] = n - w + 1
}
return(l)
}
l <- sekvens(datalength, 100, 10)
# --- multivariate estimations for dX
# new ---
library(jsonlite)
library(yuima)
library(riskbutlerRadar)
library(foreach)
datalength <- 300
chf <- getData(request = list(class = "FX", base_currency = "DKK", currency = "CHF", frequency = "day", limit = datalength))
sek <- getData(request = list(class = "FX", base_currency = "DKK", currency = "SEK", frequency = "day", limit = datalength))
xdata <- data.frame(chf, sek)
#write.csv(xdata, "./marketdata_daily_base_DKK.csv", row.names=FALSE)
cor(xdata)
plot(xdata)
sekvens <- function(n, w, s) {
l <- seq(1, n - w + s, s)
if ((l[length(l)] + w - 1) > n ) {
l[length(l)] = n - w + 1
}
return(l)
}
l <- sekvens(datalength, 100, 10)
funparam <- function(data, model = "you3", correlated = FALSE) {
rho <- 0
if (correlated == TRUE) {
rho <- cor(data)[2,1]
}
# dX = θ1·(θ2 - X)·dt + θ3·X·dW, Brennan & Schwartz 1980
if (model == "you3") {
b <- c("p1.1 * (p2.1 - x1)", "p1.2 * (p2.2 - x2)")
e21 <- gsub("rho", rho, "(p3.2 * x2) * rho")
e22 <- gsub("rho", rho, "(p3.2 * x2) * sqrt(1 - (rho)^2)")
s <- matrix(c("p3.1 * x1", e21, 0, e22), 2, 2)
slu <- jsonlite::fromJSON('{"start": {"p1.1": 1,"p2.1": 0.1,"p3.1": 0.1, "p1.2": 1,"p2.2": 0.1,"p3.2": 0.1}, "lower": {"p1.1": -100,"p2.1": 0,"p3.1": 0, "p1.2": -100,"p2.2": 0,"p3.2": 0}, "upper": {"p1.1": 100,"p2.1": 100,"p3.1": 100, "p1.2": 100,"p2.2": 100,"p3.2": 100}}')
sol <- c("x1", "x2")
# dX = θ1·(θ2 - X)·dt + θ3·X^θ4·dW, Chan-Karolyi-Longstaff-Sanders 1992
} else if (model == "yckls") {
b <- c("p1.1 * (p2.1 - x1)", "p1.2 * (p2.2 - x2)")
e21 <- gsub("rho", rho, "(p3.2 * x2^p4.2) * rho")
e22 <- gsub("rho", rho, "(p3.2 * x2^p4.2) * sqrt(1 - (rho)^2)")
s <- matrix(c("p3.1 * x1^p4.1", e21, 0, e22), 2, 2)
slu <- jsonlite::fromJSON('{"start": {"p1.1": 1,"p2.1": 0.1,"p3.1": 0.1, "p4.1": 1, "p1.2": 1,"p2.2": 0.1,"p3.2": 0.1, "p4.2": 1}, "lower": {"p1.1": -100,"p2.1": 0,"p3.1": 0, "p4.1": 0, "p1.2": -100,"p2.2": 0,"p3.2": 0, "p4.2": 0}, "upper": {"p1.1": 100,"p2.1": 100,"p3.1": 100, "p4.1": 2, "p1.2": 100,"p2.2": 100,"p3.2": 100, "p4.1": 2}}')
sol <- c("x1", "x2")
# dX = sigma^2/2·(beta - gamma·X/Sqrt(delta^2 + (X - mu)^2)·dt + sigma·dW, Hyperbolic diffusion (dynamics of sand - the sand project, AAU); Iacus, 2011, Chicago R/Finance, April 29
} else if (model == "yhdf") {
b <- c("(p1.1^2)/2 * (p2.1 - p3.1 * x1 /sqrt(p4.1^2 + (x1 - p5.1)^2))", "(p1.2^2)/2 * (p2.2 - p3.2 * x2 /sqrt(p4.2^2 + (x2 - p5.2)^2))")
e21 <- gsub("rho", rho, "p1.2 * rho")
e22 <- gsub("rho", rho, "p1.2 * sqrt(1 - (rho)^2)")
s <- matrix(c("p1.1", e21, 0, e22), 2, 2)
slu <- jsonlite::fromJSON('{"start": {"p1.1": 0.1,"p2.1": 0.1,"p3.1": 0.1, "p4.1": 0.1, "p5.1": 0.1, "p1.2": 0.1,"p2.2": 0.1,"p3.2": 0.1, "p4.2": 0.1, "p5.2": 0.1}, "lower": {"p1.1": 0,"p2.1": -100,"p3.1": -1, "p4.1": 0, "p5.1": -100, "p1.2": 0,"p2.2": -100,"p3.2": -1, "p4.2": 0, "p5.2": -100}, "upper": {"p1.1": 1,"p2.1": 100,"p3.1": 1, "p4.1": 1, "p5.1": 100, "p1.2": 1,"p2.2": 100,"p3.2": 1, "p4.1": 1, "p5.2": 100}}')
sol <- c("x1", "x2")
}
return(list(drift = b, diffusion = s, solve.variable = sol, slu = slu))
}
funcor <- function(data, model = "you3", correlated = FALSE, start) {
p <- funparam(data, model, correlated)
if (missing(start)) {
start = p$slu$start
}
est <- riskbutlerRadar::yuima.qmle(log(data), delta = 1/365, drift = p$drift, diffusion = p$diffusion, solve.variable = p$solve.variable, method="L-BFGS-B", start = start, lower = p$slu$lower, upper = p$slu$upper, summary = FALSE)
return(est)
}
sys.time(funcor(xdata))
sys.time()
Sys.time(funcor(xdata))
proc.time
proc.time()
ptm <- proc.time()
ptm <- proc.time(); funcor(xdata); proc.time() - ptm
ptm <- proc.time(); funcor(xdata); proc.time() - ptm
ptm <- proc.time()
aiUpdown()
proc.time() - ptm
library(riskbutlerRadar)
library(riskbutlerRadar)
library(riskbutlerRadar)
library(riskbutlerRadar)
