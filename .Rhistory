est = start
r <- foreach(i=seq(1,length(data)-w+step,step), .combine = cbind) %doParallel::dopar% {
dat <- data[seq(i,i+w-1)]
dat <- yuima::setData(dat, delta = delta)
yobj <- yuima::setYuima(model = ymod, data = dat)
res <- yuima::qmle(yobj, start = est, ...)
# To use estimates as start values in next or other qmle estimation set: start = as.list(res@coef)
est <- as.list(res@coef)
#print(res)
# r <- cbind(r, res@coef)
res@coef
}
return(r)
}
ptm <- proc.time(); yuima.qmle.seq(data = log(ar), delta = 1/(24*365), drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = 0, sigma = 0), upper = list(mu = 0.50, sigma = 1)); proc.time() - ptm
yuima.qmle.seq <- function(data, delta = 1/252, summary = TRUE, drift, diffusion, hurst = 0.5, solve.variable = "x", start, ...) {
ymod <- yuima::setModel(drift = drift, diffusion = diffusion, hurst = hurst, solve.variable = solve.variable, state.variable = solve.variable)
# check foreach further: even, uneven indexes; vector or matrix etc.
#r <- c()
w <- 100
step <- 10
est = start
r <- foreach(i=seq(1,length(data)-w+step,step), .combine = cbind) %dopar% {
dat <- data[seq(i,i+w-1)]
dat <- yuima::setData(dat, delta = delta)
yobj <- yuima::setYuima(model = ymod, data = dat)
res <- yuima::qmle(yobj, start = est, ...)
# To use estimates as start values in next or other qmle estimation set: start = as.list(res@coef)
est <- as.list(res@coef)
#print(res)
# r <- cbind(r, res@coef)
res@coef
}
return(r)
}
ptm <- proc.time(); yuima.qmle.seq(data = log(ar), delta = 1/(24*365), drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = 0, sigma = 0), upper = list(mu = 0.50, sigma = 1)); proc.time() - ptm
ptm <- proc.time(); yuima.qmle.seq(data = log(ar), delta = 1/(24*365), drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = 0, sigma = 0), upper = list(mu = 0.50, sigma = 1)); proc.time() - ptm
ptm <- proc.time(); yuima.qmle.seq(data = log(ar), delta = 1/(24*365), drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = 0, sigma = 0), upper = list(mu = 0.50, sigma = 1)); proc.time() - ptm
ptm <- proc.time(); yuima.qmle.seq(data = log(ar), delta = 1/(24*365), drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = 0, sigma = 0), upper = list(mu = 0.50, sigma = 1)); proc.time() - ptm
ptm <- proc.time(); yuima.qmle.seq(data = log(ar), delta = 1/(24*365), drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = 0, sigma = 0), upper = list(mu = 0.50, sigma = 1)); proc.time() - ptm
ptm <- proc.time(); yuima.qmle.seq(data = log(ar), delta = 1/(24*365), drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = 0, sigma = 0), upper = list(mu = 0.50, sigma = 1)); proc.time() - ptm
yuima.qmle.seq <- function(data, delta = 1/252, summary = TRUE, drift, diffusion, hurst = 0.5, solve.variable = "x", start, ...) {
ymod <- yuima::setModel(drift = drift, diffusion = diffusion, hurst = hurst, solve.variable = solve.variable, state.variable = solve.variable)
# check foreach further: even, uneven indexes; vector or matrix etc.
#r <- c()
w <- 100
step <- 10
est = start
# %dopar%
r <- foreach(i=seq(1,length(data)-w+step,step), .combine = cbind) %do% {
dat <- data[seq(i,i+w-1)]
dat <- yuima::setData(dat, delta = delta)
yobj <- yuima::setYuima(model = ymod, data = dat)
res <- yuima::qmle(yobj, start = est, ...)
# To use estimates as start values in next or other qmle estimation set: start = as.list(res@coef)
est <- as.list(res@coef)
#print(res)
# r <- cbind(r, res@coef)
res@coef
}
return(r)
}
ptm <- proc.time(); yuima.qmle.seq(data = log(ar), delta = 1/(24*365), drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = 0, sigma = 0), upper = list(mu = 0.50, sigma = 1)); proc.time() - ptm
ptm <- proc.time(); yuima.qmle.seq(data = log(ar), delta = 1/(24*365), drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = 0, sigma = 0), upper = list(mu = 0.50, sigma = 1)); proc.time() - ptm
ptm <- proc.time(); yuima.qmle.seq(data = log(ar), delta = 1/(24*365), drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = 0, sigma = 0), upper = list(mu = 0.50, sigma = 1)); proc.time() - ptm
getDoParWorkers()
cl <- makeCluster(8)
registerDoParallel(cl)
ptm <- proc.time(); yuima.qmle.seq(data = log(ar), delta = 1/(24*365), drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = 0, sigma = 0), upper = list(mu = 0.50, sigma = 1)); proc.time() - ptm
registerDoParallel()
getDoParWorkers()
yuima.qmle.seq <- function(data, delta = 1/252, summary = TRUE, drift, diffusion, hurst = 0.5, solve.variable = "x", start, ...) {
ymod <- yuima::setModel(drift = drift, diffusion = diffusion, hurst = hurst, solve.variable = solve.variable, state.variable = solve.variable)
# check foreach further: even, uneven indexes; vector or matrix etc.
#r <- c()
w <- 100
step <- 10
est = start
# %dopar% or %do%
r <- foreach(i=seq(1,length(data)-w+step,step), .combine = cbind) %dopar% {
dat <- data[seq(i,i+w-1)]
dat <- yuima::setData(dat, delta = delta)
yobj <- yuima::setYuima(model = ymod, data = dat)
res <- yuima::qmle(yobj, start = est, ...)
# To use estimates as start values in next or other qmle estimation set: start = as.list(res@coef)
est <- as.list(res@coef)
#print(res)
# r <- cbind(r, res@coef)
res@coef
}
return(r)
}
ptm <- proc.time(); yuima.qmle.seq(data = log(ar), delta = 1/(24*365), drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = 0, sigma = 0), upper = list(mu = 0.50, sigma = 1)); proc.time() - ptm
ptm <- proc.time(); yuima.qmle.seq(data = log(ar), delta = 1/(24*365), drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = 0, sigma = 0), upper = list(mu = 0.50, sigma = 1)); proc.time() - ptm
yuima.qmle.seq <- function(data, delta = 1/252, summary = TRUE, drift, diffusion, hurst = 0.5, solve.variable = "x", start, ...) {
ymod <- yuima::setModel(drift = drift, diffusion = diffusion, hurst = hurst, solve.variable = solve.variable, state.variable = solve.variable)
# check foreach further: even, uneven indexes; vector or matrix etc.
#r <- c()
w <- 100
step <- 10
est = start
# %dopar% or %do%
r <- foreach(i=seq(1,length(data)-w+step,step), .combine = cbind) %do% {
dat <- data[seq(i,i+w-1)]
dat <- yuima::setData(dat, delta = delta)
yobj <- yuima::setYuima(model = ymod, data = dat)
res <- yuima::qmle(yobj, start = est, ...)
# To use estimates as start values in next or other qmle estimation set: start = as.list(res@coef)
est <- as.list(res@coef)
#print(res)
# r <- cbind(r, res@coef)
res@coef
}
return(r)
}
ptm <- proc.time(); yuima.qmle.seq(data = log(ar), delta = 1/(24*365), drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = 0, sigma = 0), upper = list(mu = 0.50, sigma = 1)); proc.time() - ptm
ptm <- proc.time(); yuima.qmle.seq(data = log(ar), delta = 1/(24*365), drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = 0, sigma = 0), upper = list(mu = 0.50, sigma = 1)); proc.time() - ptm
?proc.time
system.time( yuima.qmle.seq(data = log(ar), delta = 1/(24*365), drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = 0, sigma = 0), upper = list(mu = 0.50, sigma = 1)))
?list
pts <- list(x = cars[,1], y = cars[,2])
y1 <- 100*exp(rnorm(100, mean=0, sd=0.10));
y2 <- 100*exp(rnorm(100, mean=0, sd=0.10))
xdata <- list(x1 = y1, x2 = y2)
xdata$x1
xdata$x2
sol <- c("x1", "x2")
b <- c("-theta1 * x1","-x1 - theta2 * x2")
s <- matrix(c("1","0","x2","x1","gamma","0"),2,3)
yuima.qmle(data = xdata, delta = 1/365, drift = b, diffusion = s, hurst = 0.5, solve.variable = sol, start = list(theta1 = 0.1, theta2 = 0.1, gamma = 0.1), method = "L-BFGS-B", lower = list(theta1 = 0, theta2 = 0, gamma = 0), upper = list(theta1 = 5, theta2 = 5, gamma = 5))
library(radar)
yuima.qmle(data = xdata, delta = 1/365, drift = b, diffusion = s, hurst = 0.5, solve.variable = sol, start = list(theta1 = 0.1, theta2 = 0.1, gamma = 0.1), method = "L-BFGS-B", lower = list(theta1 = 0, theta2 = 0, gamma = 0), upper = list(theta1 = 5, theta2 = 5, gamma = 5))
xdata <- matrix(y1,y2)
xdata <- matrix(cbind(y1,y2))
xdata
xdata <- matrix(rbind(y1,y2))
xdata
xdata <- c(y1,y2)
xdata
xdata <- matrix(c(y1,y2),2,1)
xdata
xdata <- matrix(c(y1,y2),2,100)
xdata
yuima.qmle(data = xdata, delta = 1/365, drift = b, diffusion = s, hurst = 0.5, solve.variable = sol, start = list(theta1 = 0.1, theta2 = 0.1, gamma = 0.1), method = "L-BFGS-B", lower = list(theta1 = 0, theta2 = 0, gamma = 0), upper = list(theta1 = 5, theta2 = 5, gamma = 5))
;
dat <- toJSON(structure(list(y1,y2), .Names = c("x1","x2")))
library(jsonlite)
dat <- toJSON(structure(list(y1,y2), .Names = c("x1","x2")))
xdata <- fromJSON(dat)
xdata
list(x1 = y1, x2 = y2)
yuima.qmle(data = xdata, delta = 1/365, drift = b, diffusion = s, hurst = 0.5, solve.variable = sol, start = list(theta1 = 0.1, theta2 = 0.1, gamma = 0.1), method = "L-BFGS-B", lower = list(theta1 = 0, theta2 = 0, gamma = 0), upper = list(theta1 = 5, theta2 = 5, gamma = 5))
data.frame(xdata)
library(zoo)
yuima.qmle(data = xdata, delta = 1/365, drift = b, diffusion = s, hurst = 0.5, solve.variable = sol, start = list(theta1 = 0.1, theta2 = 0.1, gamma = 0.1), method = "L-BFGS-B", lower = list(theta1 = 0, theta2 = 0, gamma = 0), upper = list(theta1 = 5, theta2 = 5, gamma = 5))
library(radar)
yuima.qmle(data = xdata, delta = 1/365, drift = b, diffusion = s, hurst = 0.5, solve.variable = sol, start = list(theta1 = 0.1, theta2 = 0.1, gamma = 0.1), method = "L-BFGS-B", lower = list(theta1 = 0, theta2 = 0, gamma = 0), upper = list(theta1 = 5, theta2 = 5, gamma = 5))
ar <- 100*exp(rnorm(100, mean=0, sd=0.10))
yuima.qmle(data = log(ar), delta = 1/(24*365), drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = -10, sigma = 0), upper = list(mu = 10, sigma = 2))
yuima.qmle(data = log(ar), delta = 1/(24*365), drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = -10, sigma = 0), upper = list(mu = 10, sigma = 2))
yuima.qmle(data = log(ar), delta = 1/(24*365), drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = -10, sigma = 0), upper = list(mu = 10, sigma = 2))
yuima.qmle(data = log(ar), delta = 1/(24*365), drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = -10, sigma = 0), upper = list(mu = 10, sigma = 1))
yuima.qmle(data = log(ar), delta = 1/(24*365), drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = 0, sigma = 0), upper = list(mu = 10, sigma = 1))
yuima.qmle(data = log(ar), delta = 1/(24*365), drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0, sigma = 0.1), lower = list(mu = -10, sigma = 0), upper = list(mu = 10, sigma = 2))
ar <- 100*exp(rnorm(500, mean=0, sd=0.10))
yuima.qmle(data = log(ar), delta = 1/500, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0, sigma = 0.1), lower = list(mu = -10, sigma = 0), upper = list(mu = 10, sigma = 2))
yuima.qmle(data = log(ar), delta = 1/500, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0, sigma = 0.1), lower = list(mu = -10, sigma = 0), upper = list(mu = 10, sigma = 2))
yuima.qmle(data = log(ar), delta = 1/500, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0, sigma = 0.1), lower = list(mu = -10, sigma = 0), upper = list(mu = 10, sigma = 1))
yuima.qmle(data = log(ar), delta = 1/500, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0, sigma = 0.1), lower = list(mu = 0, sigma = 0), upper = list(mu = 10, sigma = 1))
ar
yuima.qmle(data = ar, delta = 1/500, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0, sigma = 0.1), lower = list(mu = 0, sigma = 0), upper = list(mu = 10, sigma = 1))
plot(ar)
hist(ar)
mean(ar)
ar <- exp(rnorm(500, mean=0, sd=0.10))
hist(ar)
plot(ar,type=l)
plot(ar,type="l")
yuima.qmle(data = ar, delta = 1/500, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0, sigma = 0.1), lower = list(mu = 0, sigma = 0), upper = list(mu = 10, sigma = 1))
yuima.qmle(data = ar, delta = 1/500, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0, sigma = 0.1), lower = list(mu = -1, sigma = 0), upper = list(mu = 1, sigma = 1))
yuima.qmle(data = ar, delta = 1/500, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0, sigma = 0.1), lower = list(mu = -2, sigma = 0), upper = list(mu = 2, sigma = 1))
yuima.qmle(data = ar, delta = 1/500, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0, sigma = 0.1), lower = list(mu = 0, sigma = 0), upper = list(mu = 10, sigma = 1))
ar <- rnorm(500, mean=0, sd=0.10)
plot(ar)
plot(ar,type="l")
yuima.qmle(data = ar, delta = 1/500, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0, sigma = 0.1), lower = list(mu = -10, sigma = 0), upper = list(mu = 10, sigma = 1))
yuima.qmle(data = ar, delta = 1/500, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0, sigma = 0.1), lower = list(mu = -10, sigma = 0), upper = list(mu = 10, sigma = 1))
yuima.qmle(data = ar,, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0, sigma = 0.1), lower = list(mu = -10, sigma = 0), upper = list(mu = 10, sigma = 1))
y1 <- 100*exp(rnorm(100, mean=0, sd=0.10))
y2 <- 100*exp(rnorm(100, mean=0, sd=0.10))
x <- data.frame(data)
x <- data.frame(list(y1,y2))
x
str(x)
x <- data.frame(list(y1=y1,y2=y2))
x
x[1:10]
x[1:10,]
data <- x
w <- 100
step <- 10
r <- foreach(i=seq(1,length(data)-w+step,step), .combine = cbind) %do% {
dat <- data[seq(i,i+w-1)]
r <- cbind(r, dat)
}
r
library(foreach)
data <- x
w <- 100
step <- 10
r <- foreach(i=seq(1,length(data)-w+step,step), .combine = cbind) %do% {
dat <- data[seq(i,i+w-1)]
r <- cbind(r, dat)
}
r
data <- x
r <- c()w <- 100
step <- 10
r <- foreach(i=seq(1,length(data)-w+step,step), .combine = cbind) %do% {
dat <- data[seq(i,i+w-1)]
r <- cbind(r, dat)
}
r
data <- x
r <- c(); w <- 100
step <- 10
r <- foreach(i=seq(1,length(data)-w+step,step), .combine = cbind) %do% {
dat <- data[seq(i,i+w-1)]
r <- cbind(r, dat)
}
r
r
r <- c()
data <- x
w <- 100
step <- 10
library(foreach)
y1 <- 100*exp(rnorm(100, mean=0, sd=0.10))
y2 <- 100*exp(rnorm(100, mean=0, sd=0.10))
data <- list(x1 = y1, x2 = y2)
r <- c()
w <- 100
step <- 10
r <- foreach(i=seq(1,length(data)-w+step,step), .combine = cbind) %do% {
dat <- data[seq(i,i+w-1)]
r <- cbind(r, dat)
}
r <- foreach(i=seq(1,length(data)-w+step,step), .combine = cbind) %do% {
dat <- data[seq(i,i+w-1)]
r <- cbind(r, dat)
}
length(data)
zz <- toJSON(structure(list(y1,y2), .Names = c("x1","x2")))
zz
library(jsonlite)
zz <- toJSON(structure(list(y1,y2), .Names = c("x1","x2")))
zz
xdata <- fromJSON(zz)
xdata
length(xdata)
length(xdata[0])
xdata$x1
length(xdata$x1)
length(xdata[1,])
length(xdata[,2])
str(xdata)
head(xdata)
tail(xdata)
ncol(xdata)
NROW(xdata)
nrow(xdata)
NROW(xdata)
NCOL(xdata)
ncol(xdata)
data <- y1
r <- c()
w <- 100
step <- 10
r <- foreach(i=seq(1,length(data)-w+step,step), .combine = cbind) %do% {
dat <- data[seq(i,i+w-1)]
r <- cbind(r, dat)
}
r
r
str(r)
y1
seq(1,length(data)-w+step,step)
length(data)
y1 <- 100*exp(rnorm(200, mean=0, sd=0.10))
y2 <- 100*exp(rnorm(200, mean=0, sd=0.10))
data <- y1
r <- c()
w <- 100
step <- 10
r <- foreach(i=seq(1,length(data)-w+step,step), .combine = cbind) %do% {
dat <- data[seq(i,i+w-1)]
r <- cbind(r, dat)
}
r
y1 <- 100*exp(rnorm(200, mean=0, sd=0.10))
y2 <- 100*exp(rnorm(200, mean=0, sd=0.10))
data <- list(x1 = y1, x2 = y2)
data <- y1
r <- c()
w <- 100
step <- 10
r <- foreach(i=seq(1,length(data)-w+step,step), .combine = cbind) %do% {
dat <- data[seq(i,i+w-1)]
#r <- cbind(r, dat)
}
r
seq(1,length(data)-w+step,step)
y1
length(data)
library(yuima)
yuima.qmle.seq <- function(data, delta = 1/252, summary = TRUE, drift, diffusion, hurst = 0.5, solve.variable = "x", start, ...) {
ymod <- yuima::setModel(drift = drift, diffusion = diffusion, hurst = hurst, solve.variable = solve.variable, state.variable = solve.variable)
# check foreach further: even, uneven indexes; vector or matrix etc.
#r <- c()
l <- seq(1, length(data) - w + step, step)
w <- 100
step <- 10
est = start
# %dopar% or %do%
r <- foreach(i=l, .combine = cbind) %do% {
dat <- data[seq(i,i+w-1)]
dat <- yuima::setData(dat, delta = delta)
yobj <- yuima::setYuima(model = ymod, data = dat)
res <- yuima::qmle(yobj, start = est, ...)
# To use estimates as start values in next or other qmle estimation set: start = as.list(res@coef)
est <- as.list(res@coef)
res@coef
}
return(r)
}
ar <- 100*exp(rnorm(200, mean=0, sd=0.10))
ar
yuima.qmle(data = log(ar), delta = 1/(24*365), drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = 0, sigma = 0), upper = list(mu = 0.50, sigma = 1))
library(radar)
library(foreach)
yuima.qmle(data = log(ar), delta = 1/(24*365), drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = 0, sigma = 0), upper = list(mu = 0.50, sigma = 1))
yuima.qmle.seq(data = log(ar), delta = 1/(24*365), drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = 0, sigma = 0), upper = list(mu = 0.50, sigma = 1))
xx <- yuima.qmle.seq(data = log(ar), delta = 1/(24*365), drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = 0, sigma = 0), upper = list(mu = 0.50, sigma = 1))
xx
toJSON(xx)
yuima.qmle.seq(data = log(ar), delta = 1/(24*365), summary = FALSE, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = 0, sigma = 0), upper = list(mu = 0.50, sigma = 1))
yuima.qmle(data = log(ar), delta = 1/(24*365), summary = FALSE, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = 0, sigma = 0), upper = list(mu = 0.50, sigma = 1))
yuima.qmle(data = log(ar), delta = 1/(24*365), summary = TRUE, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = 0, sigma = 0), upper = list(mu = 0.50, sigma = 1))
xx <- yuima.qmle.seq(data = log(ar), delta = 1/(24*365), drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = 0, sigma = 0), upper = list(mu = 0.50, sigma = 1))
xx
ar <- 100*exp(rnorm(252, mean=0.05, sd=0.10))
ar
yuima.qmle(data = log(ar), delta = 1/(24*365), drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = 0, sigma = 0), upper = list(mu = 0.50, sigma = 1))
plot(ar)
plot(ar,t=l)
?plot
plot(ar,type="l")
X <- yuima.simulate(setseed = FALSE, sumsim = FALSE, nsim = 10, drift = "mu * x", diffusion = "sigma * x", xinit = 100, hurst = 0.5, solve.variable = "x", Terminal = 1, n = 3, parameter = list(mu = 0.1, sigma = 0.07))
X
X <- yuima.simulate(setseed = FALSE, sumsim = FALSE, nsim = 10, drift = "mu * x", diffusion = "sigma * x", xinit = 100, hurst = 0.5, solve.variable = "x", Terminal = 1, n = 1, parameter = list(mu = 0.1, sigma = 0.07))
X
X <- yuima.simulate(setseed = FALSE, sumsim = FALSE, nsim = 500, drift = "mu * x", diffusion = "sigma * x", xinit = 100, hurst = 0.5, solve.variable = "x", Terminal = 1, n = 1, parameter = list(mu = 0.1, sigma = 0.07))
X
yuima.qmle(data = X, delta = 1/500, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = -10, sigma = 0), upper = list(mu = 10, sigma = 2))
yuima.qmle(data = X, delta = 1/500, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = -1, sigma = 0), upper = list(mu = 1, sigma = 1))
yuima.qmle(data = X, delta = 1/500, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = -0.5, sigma = 0), upper = list(mu = 0.5, sigma = 1))
plot(X, type="l")
X <- yuima.simulate(setseed = FALSE, sumsim = FALSE, nsim = 1, drift = "mu * x", diffusion = "sigma * x", xinit = 100, hurst = 0.5, solve.variable = "x", Terminal = 1, n = 500, parameter = list(mu = 0.1, sigma = 0.07))
plot(X, type="l")
yuima.qmle(data = X, delta = 1/500, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = -0.5, sigma = 0), upper = list(mu = 0.5, sigma = 1))
yuima.qmle.seq(data = X, delta = 1/500, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = -0.5, sigma = 0), upper = list(mu = 0.5, sigma = 1))
set.seed(123)
X <- yuima.qmle(data = X, delta = 1/500, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = -0.5, sigma = 0), upper = list(mu = 0.5, sigma = 1))
X
Xx
X
X <- yuima.simulate(setseed = TRUE, sumsim = FALSE, nsim = 1, drift = "mu * x", diffusion = "sigma * x", xinit = 100, hurst = 0.5, solve.variable = "x", Terminal = 1, n = 500, parameter = list(mu = 0.1, sigma = 0.07))
plot(X, type="l")
est <- yuima.qmle(data = X, delta = 1/500, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.15, sigma = 0.15), lower = list(mu = -0.5, sigma = 0), upper = list(mu = 0.5, sigma = 1))
est
est <- yuima.qmle(data = X, delta = 1/500, summary = FALSE, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.15, sigma = 0.15), lower = list(mu = -0.5, sigma = 0), upper = list(mu = 0.5, sigma = 1))
est
est@coef
as.list(est@coef)
est <- as.list(est@coef)
est
est$mu
est <- yuima.qmle.seq(data = X, delta = 1/500, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.15, sigma = 0.15), lower = list(mu = -0.5, sigma = 0), upper = list(mu = 0.5, sigma = 1))
est
est[1]
est[1,]
mean(est[1,])
mean(est[2,])
X <- yuima.simulate(setseed = TRUE, sumsim = FALSE, nsim = 1, drift = "mu * x", diffusion = "sigma * x", xinit = 100, hurst = 0.5, solve.variable = "x", Terminal = 1, n = 500, parameter = list(mu = 0.1, sigma = 0.07))
est <- yuima.qmle(data = X, delta = 1/500, summary = FALSE, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.15, sigma = 0.15), lower = list(mu = -0.5, sigma = 0), upper = list(mu = 0.5, sigma = 1))
est <- as.list(est@coef)
est$mu
est$sigma
abs(est$mu - 0.1556972)
abs(est$sigma - 0.06801812)
est <- yuima.qmle(data = X, delta = 1/500, summary = FALSE, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.15, sigma = 0.15), lower = list(mu = -0.5, sigma = 0), upper = list(mu = 0.5, sigma = 1))
abs(mean(est[1,]) - 0.06801815)
mean(est[1,])
est
est@coef
est <- yuima.qmle.seq(data = X, delta = 1/500, summary = FALSE, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.15, sigma = 0.15), lower = list(mu = -0.5, sigma = 0), upper = list(mu = 0.5, sigma = 1))
abs(mean(est[1,]) - 0.06801815)
abs(mean(est[2,]) - 0.1201217)
library(radar)
library(radar)
install.packages(roxygen2)
install.packages("roxygen2")
library(radar)
install.packages(c("curl", "jsonlite", "lubridate", "radar"))
?foreach
??foreach
library(radar)
library(radar)
?%do%
??foreach
library(radar)
library(testthat)
library(stats4)
library(yuima)
library(DBI)
library(RSQLite)
library(foreach)
library(radar)
# simulate
X <- yuima.simulate(setseed = TRUE, sumsim = FALSE, nsim = 1, drift = "mu * x", diffusion = "sigma * x", xinit = 100, hurst = 0.5, solve.variable = "x", Terminal = 1, n = 500, parameter = list(mu = 0.1, sigma = 0.07))
# estimate once
est <- yuima.qmle(data = X, delta = 1/500, summary = FALSE, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.15, sigma = 0.15), lower = list(mu = -0.5, sigma = 0), upper = list(mu = 0.5, sigma = 1))
est <- as.list(est@coef)
est
est <- yuima.qmle.seq(data = X, delta = 1/500, summary = FALSE, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.15, sigma = 0.15), lower = list(mu = -0.5, sigma = 0), upper = list(mu = 0.5, sigma = 1))
est
yuima.qmle.seq <- function(data, delta = 1/252, summary = TRUE, drift, diffusion, hurst = 0.5, solve.variable = "x", start, ...) {
ymod <- yuima::setModel(drift = drift, diffusion = diffusion, hurst = hurst, solve.variable = solve.variable, state.variable = solve.variable)
# check foreach further: even, uneven indexes; vector or matrix etc.
w <- 100
step <- 10
l <- seq(1, length(data) - w + step, step)
est = start
# %dopar% or %do%
r <- foreach::foreach(i=l, .combine = cbind, .packages="foreach") foreach::`%do%` {
#r <- foreach::foreach(i=l, .combine = cbind) %do% {
dat <- data[seq(i,i+w-1)]
dat <- yuima::setData(dat, delta = delta)
yobj <- yuima::setYuima(model = ymod, data = dat)
res <- yuima::qmle(yobj, start = est, ...)
# To use estimates as start values in next or other qmle estimation set: start = as.list(res@coef)
est <- as.list(res@coef)
res@coef
}
return(r)
}
??foreach
??%do%
?%do%
?`%do%`
vignette("nested")
?%foreach::do%
??%foreach::do%
??'%foreach::do%'
?"%foreach::do%"
??%foreach::do%
foreach::%do%
foreach::"%do%"
?namespace
??namespace
?roxygen2
??roxygen2
library(radar)
devtools::document()
library(radar)
library(radar)
search()
?foreach::%do%
??foreach::%do%
library(radar)
library(radar)
devtools::document()
library(radar)
library(radar)
devtools::document()
library(radar)
??i
library(radar)
library(radar)
library(radar)
library(radar)
i
yuima.qmle.seq <- function(data, delta = 1/252, summary = TRUE, drift, diffusion, hurst = 0.5, solve.variable = "x", start, ...) {
ymod <- yuima::setModel(drift = drift, diffusion = diffusion, hurst = hurst, solve.variable = solve.variable, state.variable = solve.variable)
# check foreach further: even, uneven indexes; vector or matrix etc.
w <- 100
step <- 10
est = start
# %dopar% or %do%
#r <- foreach::foreach(i=l, .combine = cbind, .packages="foreach") %do% {
r <- foreach::foreach(i = seq(1, length(data) - w + step, step), .combine = cbind) %do% {
dat <- data[seq(i, i+w-1)]
dat <- yuima::setData(dat, delta = delta)
yobj <- yuima::setYuima(model = ymod, data = dat)
res <- yuima::qmle(yobj, start = est, ...)
# To use estimates as start values in next or other qmle estimation set: start = as.list(res@coef)
est <- as.list(res@coef)
res@coef
}
return(r)
}
i
