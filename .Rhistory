txt_ext <- paste("For the buy-side of the", api$activity_financial, "activity: ")
tmp <- up
up <- down
down <- tmp
}
txt <- jsonlite::unbox(paste(txt_ext, "The 30 day chance of profit is", format(up * 100, digits = 2), "percent, and the risk of loss is", format(down * 100, digits = 2), "percent of the", api$activity_financial, "activity amount. The latest price is", base_currency, format(xinit, digits = 4), "=", currency, "1.0000. Info: sinan.gabel@riskbutler.com."))
}
# result
return(list(speech = txt, displayText = txt, source = jsonlite::unbox("riskbutler.net")))
}
#' Note: only FX currently, and risk time horizon 1 calendar week (7 days), data is hourly, 10000 simulations, quantiles are 1 and 99 percent, market data window is 252
# Call from api.ai is something like
# aiUpdown(id = "8c71919d-ebb6-467e-866f-0e05509afdde", timestamp = "2017-06-15T13:33:17.691Z", lang = "en", result = result, status = status, sessionId = "somerandomthing")
# ptm <- proc.time(); aiUpdown(jsonlite::fromJSON('{"parameters": {"activity_financial": "import", "amount_currency": {"amount": 100, "currency": "GBP"}, "base_currency": "DKK", "date": "2017-12-10"}}')); proc.time() - ptm
# ptm <- proc.time()
# aiUpdown()
# proc.time() - ptm
#' activity_financial export, import, trade or invest (default export, string)
#' activity date (default now + 7 calendar days, date format "2017-09-10")
library(riskbutlerRadar)
#' Forecast of chance of profit and risk of loss for api.ai (this) updown financial activity agent
#'
#' Todo: use cron to pre-generate the most used data including the FX so-called majors, once per hour
#'
#' @param result list of data from api.ai
#' @return list
#' @export
#'
aiUpdown <- function(result, ...) {
if (missing(result)) {
result <- jsonlite::fromJSON('{"parameters": {"activity_financial": "import", "amount_currency": {"amount": 100, "currency": "GBP"}, "base_currency": "DKK", "date": "2017-12-10"}}')
}
api <- result$parameters
# temporary
base_currency <- api$base_currency
currency <- api$amount_currency$currency
symbol <- paste(base_currency, currency, sep = "")
if (base_currency == currency) {
txt <- jsonlite::unbox(paste("There is no foreign exchange risk on your", api$activity_financial, "activity because the base currency", base_currency, " and activity currency", currency, " are the same. To understand how this was calculated please go to riskbutler.com."))
} else {
## . Check if results are already calculated and stored, else make new simulations; check if result and all parameters are there and correct;
recalculate <- TRUE
db <- "/var/sql/rdata.db"
sql <- sqlite.sql(url = db, stmt = paste('select * from fx where name = "', symbol, '" order by date desc limit 1', sep = ""))
if (nrow(sql) > 0) {
json <- jsonlite::fromJSON(sql$est)
if ((as.POSIXct(json$time) + 3600) > Sys.time()) {
up <- json$up
down <- json$down
xinit <- json$price
recalculate <- FALSE
}
}
if (recalculate == TRUE) {
## . Get market data
# tip: preload httr in opencpu
# tip: add date to fields to see actual data time stamps, and add verbose() to the POST parameters for more info on the call
# todo: filter weekend data out; check if a result is returned; test with lasso if model 3 is appropriate or perhaps a simpler model can be used e.g. where p4=1 <=> Brennan 92
freq <- "day"
xdata <- riskbutlerRadar::getData(request = list(class = "FX", base_currency = base_currency, currency = currency, frequency = freq, limit = 100))
## . Estimate parameters
if (freq == "hour") {
delta <- 1/(365*24)
} else {
delta <- 1/365
}
nsim <- 10000
sims <- riskbutlerRadar::simulate_all(xdata, model = "you3", T = 1/12, nsim = nsim, delta = delta, estimations = 1)
xinit <- xdata[length(xdata)]
## Make wanted statistics
sims <- sort(sims)
q <- 0.01
up <- (sims[round((1-q) * nsim)] - xinit)/xinit  # q * 100 percent chance of up = up, or more up
down <- abs((sims[round(q * nsim)] - xinit)/xinit)    # q * 100 percent chance of down = down, or further down
# Save result for later
# Use pre-calculated estimations with latest market value saved <= setup cron to make these calculations every hour
# If no result, then call opencpu directly and present result as text
dt <- Sys.time()
value <- paste('{"symbol": "',  symbol, '", "up": ', up, ', "down": ', down , ', "time": "', dt, '", "price": ', xinit, '}', sep = "")
stmt <- paste('insert into fx (name, date, est) values("', symbol, '", "', dt, '", json(\'', value, '\'))', sep = "")
sqlite.sql(url = db, stmt = stmt)
}
# Import and buy-side of trade will loose on FX changes if rate goes up, and vice versa for sell-side
txt_ext <- ""
if (api$activity_financial == "import") {
tmp <- up
up <- down
down <- tmp
} else if (api$activity_financial == "invest" | api$activity_financial == "trade") {
txt_ext <- paste("For the buy-side of the", api$activity_financial, "activity: ")
tmp <- up
up <- down
down <- tmp
}
txt <- jsonlite::unbox(paste(txt_ext, "The 30 day chance of profit is", format(up * 100, digits = 2), "percent, and the risk of loss is", format(down * 100, digits = 2), "percent of the", api$activity_financial, "activity amount. The latest price is", base_currency, format(xinit, digits = 4), "=", currency, "1.0000. Info: sinan.gabel@riskbutler.com."))
}
# result
return(list(speech = txt, displayText = txt, source = jsonlite::unbox("riskbutler.net")))
}
#' Note: only FX currently, and risk time horizon 1 calendar week (7 days), data is hourly, 10000 simulations, quantiles are 1 and 99 percent, market data window is 252
# Call from api.ai is something like
# aiUpdown(id = "8c71919d-ebb6-467e-866f-0e05509afdde", timestamp = "2017-06-15T13:33:17.691Z", lang = "en", result = result, status = status, sessionId = "somerandomthing")
# ptm <- proc.time(); aiUpdown(jsonlite::fromJSON('{"parameters": {"activity_financial": "import", "amount_currency": {"amount": 100, "currency": "GBP"}, "base_currency": "DKK", "date": "2017-12-10"}}')); proc.time() - ptm
# ptm <- proc.time()
# aiUpdown()
# proc.time() - ptm
#' activity_financial export, import, trade or invest (default export, string)
#' activity date (default now + 7 calendar days, date format "2017-09-10")
aiUpdown()
ptm <- proc.time(); aiUpdown(jsonlite::fromJSON('{"parameters": {"activity_financial": "import", "amount_currency": {"amount": 100, "currency": "HKD"}, "base_currency": "DKK", "date": "2017-12-10"}}')); proc.time() - ptm
ptm <- proc.time(); aiUpdown(jsonlite::fromJSON('{"parameters": {"activity_financial": "export", "amount_currency": {"amount": 100, "currency": "HKD"}, "base_currency": "DKK", "date": "2017-12-10"}}')); proc.time() - ptm
ptm <- proc.time(); aiUpdown(jsonlite::fromJSON('{"parameters": {"activity_financial": "invest", "amount_currency": {"amount": 100, "currency": "HKD"}, "base_currency": "DKK", "date": "2017-12-10"}}')); proc.time() - ptm
ptm <- proc.time(); aiUpdown(jsonlite::fromJSON('{"parameters": {"activity_financial": "trade", "amount_currency": {"amount": 100, "currency": "HKD"}, "base_currency": "DKK", "date": "2017-12-10"}}')); proc.time() - ptm
library(riskbutlerRadar)
library(riskbutlerRadar)
library(riskbutlerRadar)
library(riskbutlerRadar)
library(riskbutlerRadar)
library(riskbutlerRadar)
library(riskbutlerRadar)
set.seed(123)
ar <- 100*exp(rnorm(100, mean=0, sd=0.10))
X <- yuima.qmle(data = log(ar), delta = 1, summary = FALSE, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = 0, sigma = 0), upper = list(mu = 0.50, sigma = 1))
X <- stats4::summary(X)
X <- as.data.frame(X@coef)
library(testthat)
library(stats4)
library(yuima)
library(DBI)
library(RSQLite)
library(foreach)
library(riskbutlerRadar)
set.seed(123)
ar <- 100*exp(rnorm(100, mean=0, sd=0.10))
X <- yuima.qmle(data = log(ar), delta = 1, summary = FALSE, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = 0, sigma = 0), upper = list(mu = 0.50, sigma = 1))
X <- stats4::summary(X)
X <- as.data.frame(X@coef)
abs(X$Estimate[1]
X$Estimate[1]
X$Estimate[1]
X$Estimate[1]
X$Estimate[1]
set.seed(123)
ar <- 100*exp(rnorm(100, mean=0, sd=0.10))
X <- yuima.qmle(data = log(ar), delta = 1/100, summary = FALSE, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = 0, sigma = 0), upper = list(mu = 0.50, sigma = 1))
X <- stats4::summary(X)
X <- as.data.frame(X@coef)
X$Estimate[1]
X$Estimate[2]
ar <- rnorm(100, mean=0, sd=0.10)
X <- yuima.qmle(data = ar, delta = 1/100, summary = FALSE, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = 0, sigma = 0), upper = list(mu = 0.50, sigma = 1))
X <- stats4::summary(X)
X
X <- as.data.frame(X@coef)
X$Estimate[1]
X$Estimate[2]
X <- yuima.simulate(setseed = FALSE, sumsim = FALSE, nsim = 1, drift = "mu * x", diffusion = "sigma * x", xinit = 100, hurst = 0.5, solve.variable = "x", Terminal = 1, n = 365, parameter = list(mu = 0.1, sigma = 0.07))
plot(X)
set.seed(123)
ar <- yuima.simulate(setseed = FALSE, sumsim = FALSE, nsim = 1, drift = "mu * x", diffusion = "sigma * x", xinit = 100, hurst = 0.5, solve.variable = "x", Terminal = 1, n = 365, parameter = list(mu = 0.1, sigma = 0.07))
X <- yuima.qmle(data = ar, delta = 1/365, summary = FALSE, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = 0, sigma = 0), upper = list(mu = 0.50, sigma = 1))
X <- stats4::summary(X)
X
set.seed(123)
ar <- yuima.simulate(setseed = FALSE, sumsim = FALSE, nsim = 1, drift = "mu * x", diffusion = "sigma * x", xinit = 100, hurst = 0.5, solve.variable = "x", Terminal = 1, n = 365, parameter = list(mu = 0.1, sigma = 0.07))
X <- yuima.qmle(data = ar, delta = 1/365, summary = FALSE, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = 0, sigma = 0), upper = list(mu = 0.50, sigma = 1))
X <- stats4::summary(X)
X
set.seed(123)
ar <- yuima.simulate(setseed = FALSE, sumsim = FALSE, nsim = 1, drift = "mu * x", diffusion = "sigma * x", xinit = 100, hurst = 0.5, solve.variable = "x", Terminal = 1, n = 365, parameter = list(mu = 0.1, sigma = 0.07))
X <- yuima.qmle(data = ar, delta = 1/365, summary = FALSE, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = 0, sigma = 0), upper = list(mu = 0.50, sigma = 1))
X <- stats4::summary(X)
X <- as.data.frame(X@coef)
abs(X$Estimate[1] - 0.06774496 ) < 1e-5
abs(X$Estimate[2] - 0.14480042) < 1e-5
set.seed(123)
X <- yuima.simulate(setseed = TRUE, sumsim = FALSE, nsim = 1, drift = "mu * x", diffusion = "sigma * x", xinit = 100, hurst = 0.5, solve.variable = "x", Terminal = 1, n = 500, parameter = list(mu = 0.1, sigma = 0.07))
# estimate once
est <- yuima.qmle(data = X, delta = 1/500, summary = FALSE, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.15, sigma = 0.15), lower = list(mu = -0.5, sigma = 0), upper = list(mu = 0.5, sigma = 1))
est <- as.list(est@coef)
est
set.seed(123)
X <- yuima.simulate(setseed = TRUE, sumsim = FALSE, nsim = 1, drift = "mu * x", diffusion = "sigma * x", xinit = 100, hurst = 0.5, solve.variable = "x", Terminal = 1, n = 500, parameter = list(mu = 0.1, sigma = 0.07))
# estimate sequence of windows of length=100 (default) and steps=10 (default)
est <- yuima.qmle.seq(data = X, window = 500, step = 10, delta = 1/500, summary = FALSE, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.15, sigma = 0.15), lower = list(mu = -0.5, sigma = 0), upper = list(mu = 0.5, sigma = 1))
est
est[1]
est[2]
est <- yuima.qmle.seq(data = X, window = 100, step = 10, delta = 1/500, summary = FALSE, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.15, sigma = 0.15), lower = list(mu = -0.5, sigma = 0), upper = list(mu = 0.5, sigma = 1))
mean(est[1,])
mean(est[2,])
est <- yuima.qmle.seq(data = X, window = 125, step = 5, delta = 1/500, summary = FALSE, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.15, sigma = 0.15), lower = list(mu = -0.5, sigma = 0), upper = list(mu = 0.5, sigma = 1))
est
mean(est[1,])
mean(est[2,])
Sys.getenv('R_LIBS')
.libPaths()
.libPaths( c( .libPaths(), "~/R/userlib") )
.libPaths()
.libPaths()[2]
.libPaths()[1]
.libPaths( c( "~/R/userlib", .libPaths()) )
.libPaths()
library(riskbutlerRadar)
?install.packages
yuima.sde(model = "yckls")
#' yuima.sde returns parameters for some specific (yuima) sde models
#'
#' @param model (you3, yckls, yhdf)
#' @param multivariate boolean
#' @param correlated boolean, calculates correlations of data if multivariate
#' @param data multivariate data time series for multivariate modelling
#' @return list
#' @export
#' @importFrom stats cor
#'
yuima.sde <- function(model = "you3", multivariate = FALSE, correlated = FALSE, data) {
rho <- 0
if (correlated == TRUE) {
rho <- cor(data)[2,1]
}
# dX = θ1·(θ2 - X)·dt + θ3·X·dW, Brennan & Schwartz 1980
if (model == "you3" & multivariate == TRUE) {
b <- c("p1.1 * (p2.1 - x1)", "p1.2 * (p2.2 - x2)")
e21 <- gsub("rho", rho, "(p3.2 * x2) * rho")
e22 <- gsub("rho", rho, "(p3.2 * x2) * sqrt(1 - (rho)^2)")
s <- matrix(c("p3.1 * x1", e21, 0, e22), 2, 2)
slu <- jsonlite::fromJSON('{"start": {"p1.1": 1,"p2.1": 0.1,"p3.1": 0.1, "p1.2": 1,"p2.2": 0.1,"p3.2": 0.1}, "lower": {"p1.1": -100,"p2.1": 0,"p3.1": 0, "p1.2": -100,"p2.2": 0,"p3.2": 0}, "upper": {"p1.1": 100,"p2.1": 100,"p3.1": 100, "p1.2": 100,"p2.2": 100,"p3.2": 100}}')
sol <- c("x1", "x2")
} else if (model == "you3") {
b <- "p1 * (p2 - x)"
s <- "p3 * x"
slu <- jsonlite::fromJSON('{"start": {"p1": 1, "p2": 0.1, "p3": 0.1}, "lower": {"p1": -100, "p2": 0, "p3": 0}, "upper": {"p1": 100, "p2": 100, "p3": 1}}')
sol <- "x"
# dX = θ1·(θ2 - X)·dt + θ3·X^θ4·dW, Chan-Karolyi-Longstaff-Sanders 1992
} else if (model == "yckls" & multivariate == TRUE) {
b <- c("p1.1 * (p2.1 - x1)", "p1.2 * (p2.2 - x2)")
e21 <- gsub("rho", rho, "(p3.2 * x2^p4.2) * rho")
e22 <- gsub("rho", rho, "(p3.2 * x2^p4.2) * sqrt(1 - (rho)^2)")
s <- matrix(c("p3.1 * x1^p4.1", e21, 0, e22), 2, 2)
slu <- jsonlite::fromJSON('{"start": {"p1.1": 1,"p2.1": 0.1,"p3.1": 0.1, "p4.1": 1, "p1.2": 1,"p2.2": 0.1,"p3.2": 0.1, "p4.2": 1}, "lower": {"p1.1": -100,"p2.1": 0,"p3.1": 0, "p4.1": 0, "p1.2": -100,"p2.2": 0,"p3.2": 0, "p4.2": 0}, "upper": {"p1.1": 100,"p2.1": 100,"p3.1": 100, "p4.1": 2, "p1.2": 100,"p2.2": 100,"p3.2": 100, "p4.1": 2}}')
sol <- c("x1", "x2")
} else if (model == "yckls") {
b <- "p1 * (p2 - x)"
s <- "p3 * x^p4"
slu <- jsonlite::fromJSON('{"start": {"p1": 1,"p2": 0.1,"p3": 0.1,"p4": 1}, "lower": {"p1": -100,"p2": 0,"p3": 0,"p4": 0}, "upper": {"p1": 100,"p2": 100,"p3": 1,"p4": 2}}')
sol <- "x"
# dX = sigma^2/2·(beta - gamma·X/Sqrt(delta^2 + (X - mu)^2)·dt + sigma·dW, Hyperbolic diffusion (dynamics of sand - the sand project, AAU); Iacus, 2011, Chicago R/Finance, April 29
} else if (model == "yhdf" & multivariate == TRUE) {
b <- c("(p1.1^2)/2 * (p2.1 - p3.1 * x1 /sqrt(p4.1^2 + (x1 - p5.1)^2))", "(p1.2^2)/2 * (p2.2 - p3.2 * x2 /sqrt(p4.2^2 + (x2 - p5.2)^2))")
e21 <- gsub("rho", rho, "p1.2 * rho")
e22 <- gsub("rho", rho, "p1.2 * sqrt(1 - (rho)^2)")
s <- matrix(c("p1.1", e21, 0, e22), 2, 2)
slu <- jsonlite::fromJSON('{"start": {"p1.1": 0.1,"p2.1": 0.1,"p3.1": 0.2, "p4.1": 0.1, "p5.1": 0.1, "p1.2": 0.1,"p2.2": 0.1,"p3.2": 0.2, "p4.2": 0.1, "p5.2": 0.1}, "lower": {"p1.1": 0,"p2.1": 0,"p3.1": 0, "p4.1": 0, "p5.1": -100, "p1.2": 0,"p2.2": 0,"p3.2": 0, "p4.2": 0, "p5.2": -100}, "upper": {"p1.1": 1,"p2.1": 100,"p3.1": 1, "p4.1": 1, "p5.1": 100, "p1.2": 1,"p2.2": 100,"p3.2": 1, "p4.1": 1, "p5.2": 100}}')
sol <- c("x1", "x2")
} else if (model == "yhdf") {
b <- "(p1^2)/2 * (p2 - p3 * x /sqrt(p4^2 + (x - p5)^2))"
s <- "p1"
slu <- jsonlite::fromJSON('{"start": {"p1": 0.1,"p2": 0.1,"p3": 0.2,"p4": 0.1,"p5": 0.1}, "lower": {"p1": 0,"p2": 0,"p3": 0,"p4": 0,"p5": -100}, "upper": {"p1": 1,"p2": 100,"p3": 1,"p4": 1,"p5": 100}}')
sol <- "x"
}
return(list(drift = b, diffusion = s, solve.variable = sol, slu = slu))
}
# # univariate
# yuima.sde(model = "you3")
# yuima.sde(model = "yckls")
# yuima.sde(model = "yhdf")
#
# # multivariate
# yuima.sde(model = "you3", , multivariate = TRUE, correlated = FALSE, xdata)
# yuima.sde(model = "you3", , multivariate = TRUE, correlated = TRUE, xdata)
yuima.sde(model = "yckls")
md <- yuima.sde(model = "yckls")
md
md$drift
md$slu
md$slu$start
set.seed(123)
X <- yuima.simulate(setseed = TRUE, sumsim = FALSE, nsim = 1, drift = "mu * x", diffusion = "sigma * x", xinit = 100, hurst = 0.5, solve.variable = "x", Terminal = 1, n = 500, parameter = list(mu = 0.1, sigma = 0.07))
md <- yuima.sde(model = "yckls")
est <- yuima.qmle.seq(data = X, window = 125, step = 5, delta = 1/500, summary = FALSE, drift = md$drift, diffusion = md$diffusion, hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = md$slu$start, lower = md$slu$lower, upper = md$slu$upper)
est
mean(est[1,])
mean(est[2,])
mean(est[3,])
mean(est[4,])
as.list(est)
as.matrix(est)
dd <- as.matrix(est)
t(est)
t(est)$p1
dd <- t(est)
dd[1]
dd[1,]
dd[,1]
md <- yuima.sde(model = "yckls")
est <- yuima.qmle.seq(data = X, window = 125, step = 5, delta = 1/500, summary = TRUE, drift = md$drift, diffusion = md$diffusion, hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = md$slu$start, lower = md$slu$lower, upper = md$slu$upper)
est
est$coef
est$coef$p1
mean(est$coef$p1)
# simulate
set.seed(123)
X <- yuima.simulate(setseed = TRUE, sumsim = FALSE, nsim = 1, drift = "mu * x", diffusion = "sigma * x", xinit = 100, hurst = 0.5, solve.variable = "x", Terminal = 1, n = 500, parameter = list(mu = 0.1, sigma = 0.07))
# estimate sequence of windows of length=100 (default) and steps=10 (default)
est <- yuima.qmle.seq(data = X, window = 500, step = 10, delta = 1/500, summary = TRUE, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.15, sigma = 0.15), lower = list(mu = -0.5, sigma = 0), upper = list(mu = 0.5, sigma = 1))
est$coef$mu
est <- yuima.qmle.seq(data = X, window = 100, step = 10, delta = 1/500, summary = TRUE, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.15, sigma = 0.15), lower = list(mu = -0.5, sigma = 0), upper = list(mu = 0.5, sigma = 1))
est
est$coef
est$coef$sigma
md <- yuima.sde(model = "yckls")
est <- yuima.qmle.seq(data = X, window = 125, step = 5, delta = 1/500, summary = TRUE, drift = md$drift, diffusion = md$diffusion, hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = md$slu$start, lower = md$slu$lower, upper = md$slu$upper)
mean(est$coef$p1)
mean(est$coef$p2)
mean(est$coef$p3)
mean(est$coef$p4)
.libPaths( c( "~/R/userlib", .libPaths()) )
library(riskbutlerRadar)
.libPaths( c( "~/R/userlib", .libPaths()) )
.libPaths( c( "~/R/userlib", .libPaths()) )
library(riskbutlerRadar)
md <- yuima.sde(model = "yckls")
est <- yuima.qmle.seq(data = X, window = 125, step = 5, delta = 1/500, summary = TRUE, drift = md$drift, diffusion = md$diffusion, hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = md$slu$start, lower = md$slu$lower, upper = md$slu$upper)
mean(est$coef$p1)
mean(est$coef$p2)
mean(est$coef$p3)
mean(est$coef$p4)
abs(mean(est$coef$p1) + 0.3254493)
abs(mean(est$coef$p2) - 9.039045)
abs(mean(est$coef$p3) - 0.5958237)
abs(mean(est$coef$p4) - 0.6632483)
abs(mean(est$coef$p1) + 0.3254493) < 1e-3
abs(mean(est$coef$p2) - 9.039045) < 1e-3
library(testthat)
library(stats)
library(jsonlite)
library(stats4)
library(yuima)
library(DBI)
library(RSQLite)
library(foreach)
library(riskbutlerRadar)
context("riskbutlerRadar tests")
test_that("yuima.qmle", {
set.seed(123)
ar <- yuima.simulate(setseed = FALSE, sumsim = FALSE, nsim = 1, drift = "mu * x", diffusion = "sigma * x", xinit = 100, hurst = 0.5, solve.variable = "x", Terminal = 1, n = 365, parameter = list(mu = 0.1, sigma = 0.07))
X <- yuima.qmle(data = ar, delta = 1/365, summary = FALSE, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.10, sigma = 0.1), lower = list(mu = 0, sigma = 0), upper = list(mu = 0.50, sigma = 1))
X <- stats4::summary(X)
X <- as.data.frame(X@coef)
expect_that( abs(X$Estimate[1] - 0.06774496 ) < 1e-5, is_true() )
expect_that( abs(X$Estimate[2] - 0.14480042) < 1e-5, is_true() )
# simulate
set.seed(123)
X <- yuima.simulate(setseed = TRUE, sumsim = FALSE, nsim = 1, drift = "mu * x", diffusion = "sigma * x", xinit = 100, hurst = 0.5, solve.variable = "x", Terminal = 1, n = 500, parameter = list(mu = 0.1, sigma = 0.07))
# estimate once
est <- yuima.qmle(data = X, delta = 1/500, summary = FALSE, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.15, sigma = 0.15), lower = list(mu = -0.5, sigma = 0), upper = list(mu = 0.5, sigma = 1))
est <- as.list(est@coef)
expect_true( abs(est$mu - 0.1560092) < 1e-3)
expect_true( abs(est$sigma - 0.06807577) < 1e-3)
# See below: simulate multi
# multi
# yuima.qmle(data = log(X), drift = c("mu1 * x1", "mu2 * x2"), diffusion = matrixc(("s1*x1",0,0,"s2*x2"),2,2), hurst = 0.5, solve.variable = c("x1","x2"), delta=1/500, method= "L-BFGS-B", start = list(mu1 = 0.1, mu2 = 0.2, s1 = 0.07, s2 = 0.17),lower = list(mu1 = 0, mu2 = 0, s1 = 0, s2 = 0),upper = list(mu1 = 1, mu2 = 1, s1 = 1, s2 = 1))
# correlated
# yuima.qmle(data = log(X), drift = c("mu1 * x1", "mu2 * x2"), diffusion = matrix(c("s1*x1","s2*x2*r","0","s2*x2*sqrt(1 - r^2)"),2,2), hurst = 0.5, solve.variable = c("x1","x2"), delta=1/500, method= "L-BFGS-B", start = list(mu1 = 0.1, mu2 = 0.2, s1 = 0.07, s2 = 0.17, r=0.5),lower = list(mu1 = 0, mu2 = 0, s1 = 0, s2 = 0, r=-1),upper = list(mu1 = 1, mu2 = 1, s1 = 1, s2 = 1, r=1))
})
##
# . test multivariate too; n > 1;
# . ToDo: specify trading times i.e. the grid => see subsampling()
test_that("yuima.simulate", {
X <- yuima.simulate(setseed = TRUE, sumsim = FALSE, nsim = 1 , drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x",  xinit = 100, parameter = list(mu = 0.1, sigma = 0.07), Terminal = 1, n = 10)
expect_true( abs(stats::sd(X) - 5.397833) < 1e-2)
expect_true( abs(mean(X) - 108.1798) < 1e-2)
expect_true( length(X) == 10)
X <- yuima.simulate(setseed = TRUE, sumsim = FALSE, nsim = 1 , drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", xinit = 100, parameter = list(mu = 0.1, sigma = 0.07), Terminal = 1, n = 123)
expect_true( abs(stats::sd(X) - 4.275771) < 1e-2)
expect_true( abs(mean(X) - 107.0799) < 1e-2)
expect_true( length(X) == 123)
# multi
# X <- yuima.simulate(setseed = TRUE, sumsim = FALSE, nsim = 1, drift = c("mu1 * x1", "mu2 * x2"), diffusion = matrix(c("s1*x1",0,0,"s2*x2"),2,2), xinit = c(10,100), hurst = 0.5, solve.variable = c("x1","x2"), Terminal = 1, n = 500, parameter = list(mu1 = 0.1, mu2 = 0.2, s1 = 0.07, s2 = 0.17))
# colnames(X) <- c("V1","V2")  # X[,"V1"]
# correlated
# X <- yuima.simulate(setseed = TRUE, sumsim = FALSE, nsim = 1, drift = c("mu1 * x1", "mu2 * x2"), diffusion = matrix(c("s1*x1","s2*x2*r","0","s2*x2*sqrt(1 - r^2)"),2,2), xinit = c(10,100), hurst = 0.5, solve.variable = c("x1","x2"), Terminal = 1, n = 500, parameter = list(mu1 = 0.1, mu2 = 0.2, s1 = 0.07, s2 = 0.17, r = 0.8))
# Check correlation: plot(X)
})
test_that("yuima.qmle.seq", {
# simulate
set.seed(123)
X <- yuima.simulate(setseed = TRUE, sumsim = FALSE, nsim = 1, drift = "mu * x", diffusion = "sigma * x", xinit = 100, hurst = 0.5, solve.variable = "x", Terminal = 1, n = 500, parameter = list(mu = 0.1, sigma = 0.07))
# estimate sequence of windows of length=100 (default) and steps=10 (default)
est <- yuima.qmle.seq(data = X, window = 500, step = 10, delta = 1/500, summary = TRUE, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.15, sigma = 0.15), lower = list(mu = -0.5, sigma = 0), upper = list(mu = 0.5, sigma = 1))
expect_true( abs(est$coef$mu - 0.1560092) < 1e-3)
expect_true( abs(est$coef$sigma - 0.06807577) < 1e-3)
est <- yuima.qmle.seq(data = X, window = 100, step = 10, delta = 1/500, summary = TRUE, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.15, sigma = 0.15), lower = list(mu = -0.5, sigma = 0), upper = list(mu = 0.5, sigma = 1))
expect_true( abs(mean(est$coef$mu) -  0.1213351) < 1e-3)
expect_true( abs(mean(est$coef$sigma) - 0.06836215) < 1e-3)
# estimate sequence of windows of length=100 (default) and steps=10 (default)
est <- yuima.qmle.seq(data = X, window = 125, step = 5, delta = 1/500, summary = TRUE, drift = "mu * x", diffusion = "sigma * x", hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = list(mu = 0.15, sigma = 0.15), lower = list(mu = -0.5, sigma = 0), upper = list(mu = 0.5, sigma = 1))
expect_true( abs(mean(est$coef$mu) - 0.1209253) < 1e-3)
expect_true( abs(mean(est$coef$sigma) - 0.06849526) < 1e-3)
# ...
md <- yuima.sde(model = "yckls")
est <- yuima.qmle.seq(data = X, window = 125, step = 5, delta = 1/500, summary = TRUE, drift = md$drift, diffusion = md$diffusion, hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = md$slu$start, lower = md$slu$lower, upper = md$slu$upper)
expect_true( abs(mean(est$coef$p1) + 0.3254493) < 1e-3)
expect_true( abs(mean(est$coef$p2) - 9.039045) < 1e-3)
expect_true( abs(mean(est$coef$p3) - 0.5958237) < 1e-3)
expect_true( abs(mean(est$coef$p4) - 0.6632483) < 1e-3)
})
test_that("sqlite.sql", {
# make some data
mydata <- matrix(100*exp(rnorm(90, mean=0, sd=0.10)),ncol=3)
colnames(mydata) <- c("High","Low","Close")
mydata <- as.table(mydata)
write.csv(mydata, "./mydata.csv", row.names=FALSE)
# This connection creates an empty database if it does not exist
db <- dbConnect(RSQLite::SQLite(), dbname = "./mydata.db")
# write data to disk
dbWriteTable(conn = db, name = "mydata", value = "./mydata.csv", row.names = FALSE, header = TRUE)
on.exit(file.remove("./mydata.db"))
on.exit(file.remove("./mydata.csv"), add = TRUE)
dbDisconnect(db)
expect_that( all.equal(read.csv("./mydata.csv"), sqlite.sql(url = "./mydata.db", stmt = "select * from mydata")), is_true() )
})
test_that("eulerOne", {
set.seed(123)
dd <- exp(eulerOne(xinit = log(100), model = "yckls", Terminal = 1, nsim = 100, parameter = list(p1 = -0.03, p2 = 0.11, p3 = 0.2, p4 = 0.1)))
expect_true( abs(mean(dd) - 119.5292) < 1e-3)
expect_true( abs(sd(dd) - 25.79993) < 1e-3)
})
library(riskbutlerRadar)
length("xxx")
length("(xxx dkddk)")
?foreach
??foreach
library(foreach)
foreach(i=1:3) %do% sqrt(i)
sekvens <- function(n, w, s) {
l <- seq(1, n - w + s, s)
if ((l[length(l)] + w - 1) > n ) {
l[length(l)] <- n - w + 1
}
return(l)
}
sekvens(10, 5, 1)
sekvens(10, 5, 2)
foreach(sekvens(10, 5, 2)) %do% sqrt(i)
foreach(i = sekvens(10, 5, 2)) %do% sqrt(i)
sqrt(6)
.libPaths( c( "~/R/userlib", .libPaths()) )
library(riskbutlerRadar)
json <- readLines("~/git-private/riskbutlerRadar/tests/sde_1.json")
json <- jsonlite::fromJSON(json)
json
json <- readLines("~/git-private/riskbutlerRadar/tests/sde_1.json")
json <- jsonlite::fromJSON(json)
est <- yuima.qmle.seq(data = log(json$data), window = 100, step = 50, delta = 1/500, summary = TRUE, drift = md$drift, diffusion = md$diffusion, hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = md$slu$start, lower = md$slu$lower, upper = md$slu$upper)
md <- yuima.sde(model = "yckls")
est <- yuima.qmle.seq(data = log(json$data), window = 100, step = 50, delta = 1/500, summary = TRUE, drift = md$drift, diffusion = md$diffusion, hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = md$slu$start, lower = md$slu$lower, upper = md$slu$upper)
est
est <- yuima.qmle.seq(data = json$data, window = 100, step = 50, delta = 1/500, summary = TRUE, drift = md$drift, diffusion = md$diffusion, hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = md$slu$start, lower = md$slu$lower, upper = md$slu$upper)
est
is_valid_variable_name <- function(x, allow_reserved = TRUE, unique = FALSE)
{
ok
#is name too long?
max_name_length <- if(getRversion() < "2.13.0") 256L else 10000L
#is it a reserved variable, i.e.
#an ellipsis or two dots then a number?
if(!allow_reserved)
{
ok[x == "..."] <- FALSE
ok[grepl("^\\.{2}[[:digit:]]+$", x)] <- FALSE
}
#are names valid (and maybe unique)
ok[x != make.names(x, unique = unique)] <- FALSE
ok
}
is_valid_variable_name(multi)
is_valid_variable_name("multi")
?make.names
make.names("multi")
make.names("dat")
?call
make.names("call")
?request
?req
?params
?coef
library(riskbutlerRadar)
library(riskbutlerRadar)
set.seed(123)
X <- yuima.simulate(setseed = TRUE, sumsim = FALSE, nsim = 1, drift = "mu * x", diffusion = "sigma * x", xinit = 100, hurst = 0.5, solve.variable = "x", Terminal = 1, n = 500, parameter = list(mu = 0.1, sigma = 0.07))
md <- yuima.sde(model = "yckls")
est <- yuima.qmle.seq(data = X, window = 125, step = 5, delta = 1/500, summary = TRUE, drift = md$drift, diffusion = md$diffusion, hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = md$slu$start, lower = md$slu$lower, upper = md$slu$upper)
est
library(riskbutlerRadar)
toJSON(est)
jsonlite::toJSON(est)
?as.list
library(riskbutlerRadar)
set.seed(123)
X <- yuima.simulate(setseed = TRUE, sumsim = FALSE, nsim = 1, drift = "mu * x", diffusion = "sigma * x", xinit = 100, hurst = 0.5, solve.variable = "x", Terminal = 1, n = 500, parameter = list(mu = 0.1, sigma = 0.07))
md <- yuima.sde(model = "yckls")
est <- yuima.qmle.seq(data = X, window = 125, step = 5, delta = 1/500, summary = TRUE, drift = md$drift, diffusion = md$diffusion, hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = md$slu$start, lower = md$slu$lower, upper = md$slu$upper)
est
library(riskbutlerRadar)
library(riskbutlerRadar)
set.seed(123)
X <- yuima.simulate(setseed = TRUE, sumsim = FALSE, nsim = 1, drift = "mu * x", diffusion = "sigma * x", xinit = 100, hurst = 0.5, solve.variable = "x", Terminal = 1, n = 500, parameter = list(mu = 0.1, sigma = 0.07))
md <- yuima.sde(model = "yckls")
est <- yuima.qmle.seq(data = X, window = 125, step = 5, delta = 1/500, summary = TRUE, drift = md$drift, diffusion = md$diffusion, hurst = 0.5, solve.variable = "x", method="L-BFGS-B", start = md$slu$start, lower = md$slu$lower, upper = md$slu$upper)
est
